#!/usr/bin/env python

# BSD 3-Clause License
#
# Copyright 2023 The University of Hong Kong, Department of Computer Science
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its
#    contributors may be used to endorse or promote products derived from
#    this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import os
import sys
import argparse
import shlex
import subprocess

from collections import defaultdict, namedtuple
from argparse import SUPPRESS

try:
    from packaging.version import parse as version_parse
except ModuleNotFoundError:
    from distutils.version import LooseVersion as version_parse

from time import time

import shared.to.param as param
import shared.tn.param as param_tn
import shared.to.param as param_to
from shared.tn.interval_tree import bed_tree_from
from shared.tn.utils import file_path_from, folder_path_from, subprocess_popen, str2bool, str_none, \
    legal_range_from, log_error, log_warning, clair3_option_type

major_contigs = {"chr" + str(a) for a in list(range(1, 23)) + ["X", "Y"]}.union(
    {str(a) for a in list(range(1, 23)) + ["X", "Y"]})
major_contigs_order = ["chr" + str(a) for a in list(range(1, 23)) + ["X", "Y"]] + [str(a) for a in
                                                                                   list(range(1, 23)) + ["X", "Y"]]

MAX_STEP = 20

OutputPath_tn = namedtuple('OutputPath', [
    'log_path',
    'tmp_file_path',
    'split_bed_path',
    'candidates_path',
    'pileup_tensor_can_path',
    'vcf_output_path',
])

Clair3Option = namedtuple('Clair3Option', [
    'clair3_path',
    'model_path',
    'longphase_for_phasing',
    'ctg_name_str',
    'min_coverage',
    'snp_min_af',
    'indel_min_af',
    'longphase'
])

OutputPath_to = namedtuple('OutputPath', [
    'log_path',
    'tmp_file_path',
    'split_bed_path',
    'split_indel_bed_path',
    'candidates_path',
    'pileup_tensor_can_affirmative_path',
    'vcf_output_path',
])

supported_platforms = ['ont_r10_dorado_sup_5khz', 'ont_r10_dorado_sup_4khz', 'ont_r10_dorado_hac_5khz',
                       'ont_r10_dorado_hac_4khz', 'ont_r10_guppy', 'ilmn', 'hifi_revio'
                       ]

indel_supported_platforms = ['ont_r10_guppy', 'ont_r10', 'ont', 'hifi_revio', 'ont_r10_dorado_sup_5khz',
                       'ont_r10_dorado_hac_5khz', 'ont_r10_dorado_sup_4khz']

extend_supported_platforms = supported_platforms + ['ont_r10', 'ont']


class Tee(object):
    def __init__(self, name, mode):
        self.file = open(name, mode)
        self.stdout = sys.stdout
        sys.stdout = self

    def __del__(self):
        sys.stdout = self.stdout
        self.file.close()

    def write(self, data):
        self.file.write(data)
        self.stdout.write(data)

    def flush(self):
        self.file.flush()


def logging(str):
    if args.tee is None:
        print(str)
    else:
        args.tee.stdin.write(bytes(str + '\n', encoding='utf8'))


def create_output_folder_tn(args):
    # create temp file folder
    args.output_dir = folder_path_from(args.output_dir, create_not_found=True)
    log_path = folder_path_from(os.path.join(args.output_dir, 'logs'), create_not_found=True)
    tmp_file_path = folder_path_from(os.path.join(args.output_dir, 'tmp'), create_not_found=True)
    split_bed_path = folder_path_from(os.path.join(tmp_file_path, 'split_beds'), create_not_found=True)
    candidates_path = folder_path_from(os.path.join(tmp_file_path, 'candidates'), create_not_found=True)
    pileup_tensor_can_path = folder_path_from(os.path.join(tmp_file_path, 'pileup_tensor_can'), create_not_found=True)
    vcf_output_path = folder_path_from(os.path.join(tmp_file_path, 'vcf_output'), create_not_found=True)

    if args.platform != 'ilmn':
        clair3_log_path = folder_path_from(os.path.join(args.output_dir, 'logs', 'clair3_log'), create_not_found=True)
        clair3_phased_output_path = folder_path_from(os.path.join(tmp_file_path, 'clair3_output/phased_output'), create_not_found=True)
        clair3_vcf_output_path = folder_path_from(os.path.join(tmp_file_path, 'clair3_output/vcf'), create_not_found=True)

    output_path = OutputPath_tn(log_path=log_path,
                             tmp_file_path=tmp_file_path,
                             split_bed_path=split_bed_path,
                             candidates_path=candidates_path,
                             pileup_tensor_can_path=pileup_tensor_can_path,
                             vcf_output_path=vcf_output_path)
    return output_path


def create_output_folder_to(args):
    # create temp file folder
    args.output_dir = folder_path_from(args.output_dir, create_not_found=True)
    log_path = folder_path_from(os.path.join(args.output_dir, 'logs'), create_not_found=True)
    tmp_file_path = folder_path_from(os.path.join(args.output_dir, 'tmp'), create_not_found=True)
    split_bed_path = folder_path_from(os.path.join(tmp_file_path, 'split_beds'), create_not_found=True)
    split_indel_bed_path = folder_path_from(os.path.join(tmp_file_path, 'split_indel_beds'), create_not_found=True) if args.enable_indel_calling else None
    candidates_path = folder_path_from(os.path.join(tmp_file_path, 'candidates'), create_not_found=True)
    pileup_tensor_can_affirmative_path = folder_path_from(os.path.join(tmp_file_path, 'pileup_tensor_can_affirmative'),
                                                          create_not_found=True)
    vcf_output_path = folder_path_from(os.path.join(tmp_file_path, 'vcf_output'), create_not_found=True)

    if args.platform != 'ilmn':
        phasing_log_path = folder_path_from(os.path.join(args.output_dir, 'logs', 'phasing_log'), create_not_found=True)
        phasing_phased_vcf_output_path = folder_path_from(os.path.join(tmp_file_path, 'phasing_output/phased_vcf_output'), create_not_found=True)
        phasing_phased_bam_output_path = folder_path_from(os.path.join(tmp_file_path, 'phasing_output/phased_bam_output'), create_not_found=True)

    output_path = OutputPath_to(log_path=log_path,
                             tmp_file_path=tmp_file_path,
                             split_bed_path=split_bed_path,
                             split_indel_bed_path=split_indel_bed_path,
                             candidates_path=candidates_path,
                             pileup_tensor_can_affirmative_path=pileup_tensor_can_affirmative_path,
                             vcf_output_path=vcf_output_path)
    return output_path


def check_version(tool, pos=None, is_pypy=False):
    try:
        if is_pypy:
            proc = subprocess.run("{} -c 'import sys; print (sys.version)'".format(tool), stdout=subprocess.PIPE,
                                  shell=True)
        else:
            proc = subprocess.run([tool, "--version"], stdout=subprocess.PIPE)
        if proc.returncode != 0:
            return None
        first_line = proc.stdout.decode().split("\n", 1)[0]
        version = first_line.split()[pos]
        version = version_parse(version)
    except Exception:
        return None

    return version


def check_skip_steps_legal(args):
    skip_steps = args.skip_steps
    skip_steps_list = skip_steps.rstrip().split(",")
    if len(skip_steps_list) == 0:
        sys.exit(log_error("[ERROR] --skip_steps option provided but no skip steps index found"))
    for step in skip_steps_list:
        if int(step) < 1 or int(step) > MAX_STEP:
            sys.exit(log_error(
                "[ERROR] --skip_steps option provided but contains invalid skip steps index, should be 1-index"))


def check_python_path():
    python_path = subprocess.run("which python", stdout=subprocess.PIPE, shell=True).stdout.decode().rstrip()
    sys.exit(log_error("[ERROR] Current python execution path: {}".format(python_path)))


def check_python_version(python):
    python_path = subprocess.run("{} --version".format(python), stdout=subprocess.PIPE,
                                 shell=True).stdout.decode().rstrip()
    return python_path.split(' ')[1]


def check_tools_version(args):
    required_tool_version = {
        'python': version_parse('3.9.0'),
        'pypy': version_parse('3.6'),
        'samtools': version_parse('1.10'),
        'whatshap': version_parse('1.0'),
        'parallel': version_parse('20191122'),
    }

    tool_version = {
        'python': version_parse(check_python_version(args.python)),
        'pypy': check_version(tool=args.pypy, pos=0, is_pypy=True),
        'samtools': check_version(tool=args.samtools, pos=1),
        'parallel': check_version(tool=args.parallel, pos=2),
    }

    for tool, version in tool_version.items():
        required_version = required_tool_version[tool]
        if version is None:
            logging(log_error(
                "[ERROR] {} not found, please check if you are in the conda virtual environment".format(tool)))
            check_python_path()
        elif version < required_version:
            logging(
                log_error("[ERROR] Tool version not match, please check if you are in the conda virtual environment"))
            logging(' '.join([str(item).ljust(10) for item in ["Tool", "Version", "Required"]]))
            error_info = ' '.join([str(item).ljust(10) for item in [tool, version, '>=' + str(required_version)]])
            logging(error_info)
            check_python_path()
    return


def check_contig_in_bam(bam_fn, sorted_contig_list, samtools, allow_none=False, is_tumor=False):
    flag = 'tumor' if is_tumor else None
    if allow_none and bam_fn is None:
        return sorted_contig_list, True
    bai_process = subprocess_popen(shlex.split("{} idxstats {}".format(samtools, bam_fn)))
    contig_with_read_support_set = set()
    for row_id, row in enumerate(bai_process.stdout):
        row = row.split('\t')
        if len(row) != 4:
            continue
        contig_name, contig_length, mapped_reads, unmapped_reads = row
        if contig_name not in sorted_contig_list:
            continue
        if int(mapped_reads) > 0:
            contig_with_read_support_set.add(contig_name)
    for contig_name in sorted_contig_list:
        if contig_name not in contig_with_read_support_set:
            logging(log_warning(
                "[WARNING] Contig name {} provided but no mapped reads found in {} BAM, skip!".format(contig_name, flag)))
    filtered_sorted_contig_list = [item for item in sorted_contig_list if item in contig_with_read_support_set]

    found_contig = True
    if len(filtered_sorted_contig_list) == 0:
        found_contig = False
        logging(log_warning(
            "[WARNING] No mapped reads found in {} BAM for provided contigs set {}".format(
                flag, ' '.join(sorted_contig_list))))

    return filtered_sorted_contig_list, found_contig


def check_threads(args):
    threads = args.threads
    # sched_getaffinity is not exist in pypy
    try:
        sched_getaffinity_list = list(os.sched_getaffinity(0))
        num_cpus = len(sched_getaffinity_list)
    except:
        num_cpus = int(subprocess.run(args.python + " -c \"import os; print(len(os.sched_getaffinity(0)))\"", \
                                      stdout=subprocess.PIPE, shell=True).stdout.decode().rstrip())

    if threads > num_cpus:
        logging(log_warning(
            '[WARNING] Threads setting {} is larger than the number of available threads {} in the system,'.format(
                threads, num_cpus)))
        logging(log_warning('Set --threads={} for better parallelism.'.format(num_cpus)))
        args.threads = num_cpus
    return args


def split_extend_vcf(genotyping_mode_vcf_fn, output_fn):
    expand_region_size = param.no_of_positions
    output_ctg_dict = defaultdict(list)
    unzip_process = subprocess_popen(shlex.split("gzip -fdc %s" % (genotyping_mode_vcf_fn)))

    for row_id, row in enumerate(unzip_process.stdout):
        if row[0] == '#':
            continue
        columns = row.strip().split(maxsplit=3)
        ctg_name = columns[0]

        center_pos = int(columns[1])
        ctg_start, ctg_end = center_pos - 1, center_pos
        if ctg_start < 0:
            sys.exit(
                log_error(
                    "[ERROR] Invalid VCF input at the {}-th row {} {}".format(row_id + 1, ctg_name, center_pos)))
        if ctg_start - expand_region_size < 0:
            continue
        expand_ctg_start = ctg_start - expand_region_size
        expand_ctg_end = ctg_end + expand_region_size

        output_ctg_dict[ctg_name].append(
            ' '.join([ctg_name, str(expand_ctg_start), str(expand_ctg_end)]))

    for key, value in output_ctg_dict.items():
        ctg_output_fn = os.path.join(output_fn, key)
        with open(ctg_output_fn, 'w') as output_file:
            output_file.write('\n'.join(value))

    unzip_process.stdout.close()
    unzip_process.wait()

    know_vcf_contig_set = set(list(output_ctg_dict.keys()))

    return know_vcf_contig_set


def split_extend_bed(bed_fn, output_fn, contig_set=None, expand_region=True):
    expand_region_size = param.no_of_positions
    if not expand_region:
        expand_region_size = 0
    output_ctg_dict = defaultdict(list)
    unzip_process = subprocess_popen(shlex.split("gzip -fdc %s" % (bed_fn)))
    for row_id, row in enumerate(unzip_process.stdout):
        if row[0] == '#':
            continue
        columns = row.strip().split()
        ctg_name = columns[0]
        if contig_set and ctg_name not in contig_set:
            continue

        ctg_start, ctg_end = int(columns[1]), int(columns[2])

        if ctg_end < ctg_start or ctg_start < 0 or ctg_end < 0:
            sys.exit(log_error(
                "[ERROR] Invalid BED input at the {}-th row {} {} {}".format(row_id + 1, ctg_name, ctg_start, ctg_end)))
        expand_ctg_start = max(0, ctg_start - expand_region_size)
        expand_ctg_end = max(0, ctg_end + expand_region_size)
        output_ctg_dict[ctg_name].append(
            ' '.join([ctg_name, str(expand_ctg_start), str(expand_ctg_end)]))

    for key, value in output_ctg_dict.items():
        ctg_output_fn = os.path.join(output_fn, key)
        with open(ctg_output_fn, 'w') as output_file:
            output_file.write('\n'.join(value))

    unzip_process.stdout.close()
    unzip_process.wait()


def write_region_bed(region):
    try:
        ctg_name, start_end = region.split(':')
        ctg_start, ctg_end = int(start_end.split('-')[0]) - 1, int(start_end.split('-')[1]) - 1  # bed format
    except:
        sys.exit("[ERROR] Please use the correct format for --region: ctg_name:start-end, your input is {}".format(
            region))
    if ctg_end < ctg_start or ctg_start < 0 or ctg_end < 0:
        sys.exit("[ERROR] Invalid region input: {}".format(region))

    output_bed_path = os.path.join(args.output_dir, 'tmp', 'region.bed')
    with open(output_bed_path, 'w') as f:
        f.write('\t'.join([ctg_name, str(ctg_start), str(ctg_end)]) + '\n')
    return output_bed_path


def check_contigs_intersection_tn(args, fai_fn):
    MIN_CHUNK_LENGTH = 200000
    MAX_CHUNK_LENGTH = 20000000
    is_include_all_contigs = args.include_all_ctgs
    is_bed_file_provided = args.bed_fn is not None or args.region is not None
    is_known_vcf_file_provided = args.genotyping_mode_vcf_fn is not None
    is_ctg_name_list_provided = args.ctg_name is not None

    if args.region is not None:
        args.bed_fn = write_region_bed(args.region)

    split_bed_path = os.path.join(args.output_dir, 'tmp', 'split_beds')
    tree = bed_tree_from(bed_file_path=args.bed_fn, region=args.region)
    know_vcf_contig_set = split_extend_vcf(genotyping_mode_vcf_fn=args.genotyping_mode_vcf_fn, output_fn=split_bed_path) if is_known_vcf_file_provided else set()
    contig_set = set(args.ctg_name.split(',')) if is_ctg_name_list_provided else set()

    if not args.include_all_ctgs:
        logging("[INFO] --include_all_ctgs not enabled, use chr{1..22,X,Y} and {1..22,X,Y} by default")
    else:
        logging("[INFO] --include_all_ctgs enabled")

    if is_ctg_name_list_provided and is_bed_file_provided:
        logging(log_warning("[WARNING] both --ctg_name and --bed_fn provided, will only proceed with the contigs appeared in both"))

    if is_ctg_name_list_provided and is_known_vcf_file_provided:
        logging(log_warning("[WARNING] both --ctg_name and --genotyping_mode_vcf_fn provided, will only proceed with the contigs appeared in both"))

    if is_ctg_name_list_provided:
        contig_set = contig_set.intersection(
            set(tree.keys())) if is_bed_file_provided else contig_set
        contig_set = contig_set.intersection(
            know_vcf_contig_set) if is_known_vcf_file_provided else contig_set
    else:
        contig_set = contig_set.union(
            set(tree.keys())) if is_bed_file_provided else contig_set

        contig_set = contig_set.union(
            know_vcf_contig_set) if is_known_vcf_file_provided else contig_set

    # if each split region is too small(long) for given default chunk num, will increase(decrease) the total chunk num
    default_chunk_num = 0
    DEFAULT_CHUNK_SIZE = args.chunk_size
    contig_length_list = []
    contig_chunk_num = {}

    with open(fai_fn, 'r') as fai_fp:
        for row in fai_fp:
            columns = row.strip().split("\t")
            contig_name, contig_length = columns[0], int(columns[1])
            if not is_include_all_contigs and (
            not (is_bed_file_provided or is_ctg_name_list_provided or is_known_vcf_file_provided)) and str(
                    contig_name) not in major_contigs:
                continue

            if is_bed_file_provided and contig_name not in tree:
                continue
            if is_ctg_name_list_provided and contig_name not in contig_set:
                continue
            if is_known_vcf_file_provided and contig_name not in contig_set:
                continue

            contig_set.add(contig_name)
            contig_length_list.append(contig_length)
            chunk_num = int(
                contig_length / float(DEFAULT_CHUNK_SIZE)) + 1 if contig_length % DEFAULT_CHUNK_SIZE else int(
                contig_length / float(DEFAULT_CHUNK_SIZE))
            contig_chunk_num[contig_name] = max(chunk_num, 1)

    if default_chunk_num > 0:
        min_chunk_length = min(contig_length_list) / float(default_chunk_num)
        max_chunk_length = max(contig_length_list) / float(default_chunk_num)

    contigs_order = major_contigs_order + list(contig_set)

    sorted_contig_list = sorted(list(contig_set), key=lambda x: contigs_order.index(x))

    found_contig = True
    if not len(contig_set):
        if is_bed_file_provided:
            all_contig_in_bed = ' '.join(list(tree.keys()))
            logging(log_warning("[WARNING] No contig in --bed_fn was found in the reference, contigs in BED {}: {}".format(args.bed_fn, all_contig_in_bed)))
        if is_known_vcf_file_provided:
            all_contig_in_vcf = ' '.join(list(know_vcf_contig_set))
            logging(log_warning("[WARNING] No contig in --genotyping_mode_vcf_fn was found in the reference, contigs in VCF {}: {}".format(args.genotyping_mode_vcf_fn, all_contig_in_vcf)))
        if is_ctg_name_list_provided:
            all_contig_in_ctg_name = ' '.join(args.ctg_name.split(','))
            logging(log_warning("[WARNING] No contig in --ctg_name was found in the reference, contigs in contigs list: {}".format(all_contig_in_ctg_name)))
        found_contig = False
    else:
        for c in sorted_contig_list:
            if c not in contig_chunk_num:
                logging(log_warning(("[WARNING] Contig {} given but not found in the reference".format(c))))

        # check contig in bam have support reads
        sorted_contig_list, tumor_found_contig = check_contig_in_bam(bam_fn=args.bam_fn, sorted_contig_list=sorted_contig_list,
                                                               samtools=args.samtools, is_tumor=True)

        sorted_contig_list, normal_found_contig = check_contig_in_bam(bam_fn=args.control_bam_fn, sorted_contig_list=sorted_contig_list,
                                                               samtools=args.samtools, allow_none=False, is_tumor=False)
        found_contig = tumor_found_contig and normal_found_contig

    if not found_contig:
        log_warning("[WARNING] Exit calling because no contig was found in BAM!")
        sys.exit(0)
    logging('[INFO] Call variants in contigs: {}'.format(' '.join(sorted_contig_list)))
    logging('[INFO] Number of chunks for each contig: {}'.format(
        ' '.join([str(contig_chunk_num[c]) for c in sorted_contig_list])))

    if default_chunk_num > 0 and max_chunk_length > MAX_CHUNK_LENGTH:
        logging(log_warning(
            '[WARNING] The maximum chunk size set {} is larger than the suggested maximum chunk size {}, consider setting a larger --chunk_num= instead for better parallelism.'.format(
                min_chunk_length, MAX_CHUNK_LENGTH)))

    elif default_chunk_num > 0 and min_chunk_length < MIN_CHUNK_LENGTH:
        logging(log_warning(
            '[WARNING] The minimum chunk size set {} is smaller than the suggested minimum chunk size {}, consider setting a smaller --chunk_num= instead.'.format(
                min_chunk_length, MIN_CHUNK_LENGTH)))

    if default_chunk_num == 0 and max(contig_length_list) < DEFAULT_CHUNK_SIZE / 5:
        logging(log_warning(
            '[WARNING] The length of the longest contig {} is more than five times smaller than the default chunk size {}, consider setting a smaller --chunk_size= instead for better parallelism.'.format(
                max(contig_length_list), DEFAULT_CHUNK_SIZE)))

    if is_bed_file_provided:
        split_extend_bed(bed_fn=args.bed_fn, output_fn=split_bed_path, contig_set=contig_set)

    contig_path = os.path.join(args.output_dir, 'tmp', 'CONTIGS')
    with open(contig_path, 'w') as output_file:
        output_file.write('\n'.join(sorted_contig_list))

    chunk_list = []
    chunk_list_path = os.path.join(args.output_dir, 'tmp', 'CHUNK_LIST')
    with open(chunk_list_path, 'w') as output_file:
        for contig_name in sorted_contig_list:
            chunk_num = contig_chunk_num[contig_name] if args.chunk_num is None else args.chunk_num
            for chunk_id in range(1, chunk_num + 1):
                output_file.write(contig_name + ' ' + str(chunk_id) + ' ' + str(chunk_num) + '\n')
                chunk_list.append((contig_name, chunk_id, chunk_num))
    args.chunk_list = chunk_list
    if args.clair3_path is not None and args.platform != 'ilmn':
        args.clair3_option = args.clair3_option._replace(ctg_name_str=','.join(sorted_contig_list))

    return args


def check_clair3_options(args):
    conda_prefix = args.conda_prefix
    if args.clair3_path is None:
        args.clair3_path = os.path.join(conda_prefix, 'bin')
        if not os.path.exists(args.clair3_path + '/run_clair3.sh'):
            sys.exit(log_error("[ERROR] Cannot find clair3 main entry in {}".format(args.clair3_path)))

    if args.clair3_model_path is None:
        if args.platform == 'ont_r10' or args.platform == 'ont' or args.platform == 'ont_r10_guppy':
            args.clair3_model_path = os.path.join(conda_prefix, 'bin', 'tn_models', 'clair3_models', 'ont_r104_e81_sup_g5015')
        elif args.platform == 'hifi' or args.platform.startswith("hifi_revio"):
            args.clair3_model_path = os.path.join(conda_prefix, 'bin', 'tn_models', 'clair3_models', 'hifi_revio')
        elif args.platform == "ont_r10_dorado_4khz" or args.platform == "ont_r10_dorado_sup_4khz":
            args.clair3_model_path = os.path.join(conda_prefix, 'bin', 'tn_models', 'clair3_models', 'r1041_e82_400bps_sup_v410')
        elif args.platform == "ont_r10_dorado_5khz" or args.platform.startswith("ont_r10_dorado_sup_5khz"):
            args.clair3_model_path = os.path.join(conda_prefix, 'bin', 'tn_models', 'clair3_models', 'r1041_e82_400bps_sup_v420')
        elif args.platform == "ont_r10_dorado_hac_5khz":
            args.clair3_model_path = os.path.join(conda_prefix, 'bin', 'tn_models', 'clair3_models', 'r1041_e82_400bps_hac_v420')
        elif args.platform == "ont_r10_dorado_hac_4khz":
            args.clair3_model_path = os.path.join(conda_prefix, 'bin', 'tn_models', 'clair3_models', 'r1041_e82_400bps_hac_v410')

    if not os.path.exists(args.clair3_model_path):
        sys.exit(log_error("[ERROR] Cannot find clair3 model path in {}".format(args.clair3_model_path)))

    if args.longphase is None:
        args.longphase = os.path.join(conda_prefix, 'bin', 'longphase')
        if not os.path.exists(args.longphase):
            args.longphase = os.path.join(args.clair3_path, 'longphase')

    if args.whatshap is None:
        args.whatshap = os.path.join(conda_prefix, 'bin', 'whatshap')

    longphase_for_phasing = False if args.whatshap_for_phasing is True else param_tn.clair3_fast_option['longphase_for_phasing']
    if longphase_for_phasing and not os.path.exists(args.longphase):
        sys.exit(log_error("[ERROR] Cannot find longphase at {}".format(args.longphase)))
    if args.whatshap_for_phasing and not os.path.exists(args.whatshap):
        sys.exit(log_error("[ERROR] Cannot find whatshap at {}".format(args.whatshap)))

    clair3_option = param_tn.clair3_fast_option
    if args.enable_clair3_germline_output:
        # use clair3 default settings than the fast setting for germline calling
        clair3_option = param_tn.clair3_default_option

    args.clair3_min_coverage = args.clair3_min_coverage if args.clair3_min_coverage is not None else clair3_option['min_coverage']
    args.clair3_snp_min_af = args.clair3_snp_min_af if args.clair3_snp_min_af is not None else clair3_option['snp_min_af']
    args.clair3_indel_min_af = args.clair3_indel_min_af if args.clair3_indel_min_af is not None else clair3_option['indel_min_af']
    args.clair3_option = Clair3Option(
        clair3_path=args.clair3_path,
        model_path=args.clair3_model_path,
        longphase_for_phasing=longphase_for_phasing,
        ctg_name_str=None, # update in check_contigs_intersection
        min_coverage=str(args.clair3_min_coverage),
        snp_min_af=str(args.clair3_snp_min_af),
        indel_min_af=str(args.clair3_indel_min_af),
        longphase=args.longphase)

    return args


def check_contigs_intersection_to(args, fai_fn):
    MIN_CHUNK_LENGTH = 200000
    MAX_CHUNK_LENGTH = 20000000
    is_include_all_contigs = args.include_all_ctgs
    is_bed_file_provided = args.bed_fn is not None or args.region is not None
    is_known_vcf_file_provided = args.genotyping_mode_vcf_fn is not None
    is_ctg_name_list_provided = args.ctg_name is not None

    if args.region is not None:
        args.bed_fn = write_region_bed(args.region)

    split_bed_path = os.path.join(args.output_dir, 'tmp', 'split_beds')
    split_indel_bed_path = os.path.join(args.output_dir, 'tmp', 'split_indel_beds') if args.enable_indel_calling else None
    tree = bed_tree_from(bed_file_path=args.bed_fn, region=args.region)
    know_vcf_contig_set = split_extend_vcf(genotyping_mode_vcf_fn=args.genotyping_mode_vcf_fn,
                                           output_fn=split_bed_path) if is_known_vcf_file_provided else set()
    contig_set = set(args.ctg_name.split(',')) if is_ctg_name_list_provided else set()

    if not args.include_all_ctgs:
        logging("[INFO] --include_all_ctgs not enabled, use chr{1..22,X,Y} and {1..22,X,Y} by default")
    else:
        logging("[INFO] --include_all_ctgs enabled")

    if is_ctg_name_list_provided and is_bed_file_provided:
        logging(log_warning(
            "[WARNING] both --ctg_name and --bed_fn provided, will only proceed with the contigs appeared in both"))

    if is_ctg_name_list_provided and is_known_vcf_file_provided:
        logging(log_warning(
            "[WARNING] both --ctg_name and --genotyping_mode_vcf_fn provided, will only proceed with the contigs appeared in both"))

    if is_ctg_name_list_provided:
        contig_set = contig_set.intersection(
            set(tree.keys())) if is_bed_file_provided else contig_set
        contig_set = contig_set.intersection(
            know_vcf_contig_set) if is_known_vcf_file_provided else contig_set
    else:
        contig_set = contig_set.union(
            set(tree.keys())) if is_bed_file_provided else contig_set

        contig_set = contig_set.union(
            know_vcf_contig_set) if is_known_vcf_file_provided else contig_set

    # if each split region is too small(long) for given default chunk num, will increase(decrease) the total chunk num
    default_chunk_num = 0
    DEFAULT_CHUNK_SIZE = args.chunk_size
    contig_length_list = []
    contig_chunk_num = {}

    with open(fai_fn, 'r') as fai_fp:
        for row in fai_fp:
            columns = row.strip().split("\t")
            contig_name, contig_length = columns[0], int(columns[1])
            if not is_include_all_contigs and (
                    not (is_bed_file_provided or is_ctg_name_list_provided or is_known_vcf_file_provided)) and str(
                contig_name) not in major_contigs:
                continue

            if is_bed_file_provided and contig_name not in tree:
                continue
            if is_ctg_name_list_provided and contig_name not in contig_set:
                continue
            if is_known_vcf_file_provided and contig_name not in contig_set:
                continue

            contig_set.add(contig_name)
            contig_length_list.append(contig_length)
            chunk_num = int(
                contig_length / float(DEFAULT_CHUNK_SIZE)) + 1 if contig_length % DEFAULT_CHUNK_SIZE else int(
                contig_length / float(DEFAULT_CHUNK_SIZE))
            contig_chunk_num[contig_name] = max(chunk_num, 1)

    if default_chunk_num > 0:
        min_chunk_length = min(contig_length_list) / float(default_chunk_num)
        max_chunk_length = max(contig_length_list) / float(default_chunk_num)

    contigs_order = major_contigs_order + list(contig_set)

    sorted_contig_list = sorted(list(contig_set), key=lambda x: contigs_order.index(x))

    if not len(contig_set):
        if is_bed_file_provided:
            all_contig_in_bed = ' '.join(list(tree.keys()))
            logging(log_warning(
                "[WARNING] No contig in --bed_fn was found in the reference, contigs in BED {}: {}".format(args.bed_fn,
                                                                                                           all_contig_in_bed)))
        if is_known_vcf_file_provided:
            all_contig_in_vcf = ' '.join(list(know_vcf_contig_set))
            logging(log_warning(
                "[WARNING] No contig in --genotyping_mode_vcf_fn was found in the reference, contigs in VCF {}: {}".format(
                    args.genotyping_mode_vcf_fn, all_contig_in_vcf)))
        if is_ctg_name_list_provided:
            all_contig_in_ctg_name = ' '.join(args.ctg_name.split(','))
            logging(log_warning(
                "[WARNING] No contig in --ctg_name was found in the reference, contigs in contigs list: {}".format(
                    all_contig_in_ctg_name)))
        found_contig = False
    else:
        for c in sorted_contig_list:
            if c not in contig_chunk_num:
                logging(log_warning(("[WARNING] Contig {} given but not found in the reference".format(c))))

        # check contig in bam have support reads
        sorted_contig_list, tumor_found_contig = check_contig_in_bam(bam_fn=args.bam_fn,
                                                                     sorted_contig_list=sorted_contig_list,
                                                                     samtools=args.samtools, is_tumor=True)

        found_contig = tumor_found_contig

    if not found_contig:
        log_warning("[WARNING] Exit calling because no contig was found in BAM!")
        sys.exit(0)
    logging('[INFO] Call variants in contigs: {}'.format(' '.join(sorted_contig_list)))
    logging('[INFO] Number of chunks for each contig: {}'.format(
        ' '.join([str(contig_chunk_num[c]) for c in sorted_contig_list])))

    if default_chunk_num > 0 and max_chunk_length > MAX_CHUNK_LENGTH:
        logging(log_warning(
            '[WARNING] The maximum chunk size set {} is larger than the suggested maximum chunk size {}, consider setting a larger --chunk_num= instead for better parallelism.'.format(
                min_chunk_length, MAX_CHUNK_LENGTH)))

    elif default_chunk_num > 0 and min_chunk_length < MIN_CHUNK_LENGTH:
        logging(log_warning(
            '[WARNING] The minimum chunk size set {} is smaller than the suggested  minimum chunk size {}, consider setting a smaller --chunk_num= instead.'.format(
                min_chunk_length, MIN_CHUNK_LENGTH)))

    if default_chunk_num == 0 and max(contig_length_list) < DEFAULT_CHUNK_SIZE / 5:
        logging(log_warning(
            '[WARNING] The length of the longest contig {} is more than five times smaller than the default chunk size {}, consider setting a smaller --chunk_size= instead for better parallelism.'.format(
                max(contig_length_list), DEFAULT_CHUNK_SIZE)))

    if is_bed_file_provided:
        split_extend_bed(bed_fn=args.bed_fn, output_fn=split_bed_path, contig_set=contig_set)

    contig_path = os.path.join(args.output_dir, 'tmp', 'CONTIGS')
    with open(contig_path, 'w') as output_file:
        output_file.write('\n'.join(sorted_contig_list))

    chunk_list = []
    chunk_list_path = os.path.join(args.output_dir, 'tmp', 'CHUNK_LIST')
    with open(chunk_list_path, 'w') as output_file:
        for contig_name in sorted_contig_list:
            chunk_num = contig_chunk_num[contig_name] if args.chunk_num is None else args.chunk_num
            for chunk_id in range(1, chunk_num + 1):
                output_file.write(contig_name + ' ' + str(chunk_id) + ' ' + str(chunk_num) + '\n')
                chunk_list.append((contig_name, chunk_id, chunk_num))
    args.chunk_list = chunk_list

    return args


def check_args_tn(args):

    if args.conda_prefix is None:
        if 'CONDA_PREFIX' in os.environ:
            args.conda_prefix = os.environ['CONDA_PREFIX']
        else:
            try:
                python_path = subprocess.run('which python', stdout=subprocess.PIPE, shell=True).stdout.decode().rstrip()
                args.conda_prefix = os.path.dirname(os.path.dirname(python_path))
            except:
                sys.exit(log_error("[ERROR] Conda prefix not found, please activate a correct conda environment."))

    args.control_bam_fn = file_path_from(file_name=args.control_bam_fn, exit_on_not_found=True, allow_none=False)
    normal_bai_fn = file_path_from(file_name=args.control_bam_fn, suffix=".bai", exit_on_not_found=False, sep='.')
    normal_crai_fn = file_path_from(file_name=args.control_bam_fn, suffix=".crai", exit_on_not_found=False, sep='.')
    normal_csi_fn = file_path_from(file_name=args.control_bam_fn, suffix=".csi", exit_on_not_found=False, sep='.')

    args.bam_fn = file_path_from(file_name=args.bam_fn, exit_on_not_found=True)
    tumor_bai_fn = file_path_from(file_name=args.bam_fn, suffix=".bai", exit_on_not_found=False, sep='.')
    tumor_crai_fn = file_path_from(file_name=args.bam_fn, suffix=".crai", exit_on_not_found=False, sep='.')
    tumor_csi_fn = file_path_from(file_name=args.bam_fn, suffix=".csi", exit_on_not_found=False, sep='.')

    args.ref_fn = file_path_from(file_name=args.ref_fn, exit_on_not_found=True)
    fai_fn = file_path_from(file_name=args.ref_fn, suffix=".fai", exit_on_not_found=True, sep='.')
    args.bed_fn = file_path_from(file_name=args.bed_fn, exit_on_not_found=True, allow_none=True)
    args.genotyping_mode_vcf_fn = file_path_from(file_name=args.genotyping_mode_vcf_fn, exit_on_not_found=True, allow_none=True)
    args.hybrid_mode_vcf_fn = file_path_from(file_name=args.hybrid_mode_vcf_fn, exit_on_not_found=True, allow_none=True)
    args.normal_vcf_fn = file_path_from(file_name=args.normal_vcf_fn, exit_on_not_found=True, allow_none=True)

    if args.platform in param_tn.model_name_platform_dict:
        updated_platform = param_tn.model_name_platform_dict[args.platform]
        logging("[INFO] Platform parameter is using ONT model name format, change --platform {} to --platform {}".format(args.platform, updated_platform))
        args.platform = updated_platform

    if normal_bai_fn is None and normal_crai_fn is None and normal_csi_fn is None:
        sys.exit(log_error("[ERROR] Control BAM index file {} or {} not found. Please run `samtools index $BAM` first.".format(args.control_bam_fn + '.bai',
                                                                                      args.control_bam_fn + '.crai')))

    if tumor_bai_fn is None and tumor_crai_fn is None and tumor_csi_fn is None:
        sys.exit(log_error("[ERROR] Input BAM index file {} or {} not found. Please run `samtools index $BAM` first.".format(args.bam_fn + '.bai',
                                                                                      args.bam_fn + '.crai')))

    if args.enable_indel_calling and args.platform not in set(indel_supported_platforms):
        sys.exit(log_error("[ERROR] Indel calling only support {} platforms".format(','.join(indel_supported_platforms))))

    if args.genotyping_mode_vcf_fn is not None and args.hybrid_mode_vcf_fn is not None:
        sys.exit(log_error("[ERROR] Please provide either --genotyping_mode_vcf_fn or --hybrid_mode_vcf_fn only"))

    if args.pileup_model_path is None:
        args.pileup_model_path = os.path.join(args.conda_prefix, 'bin', 'tn_models', args.platform, 'pileup.pkl')

    args.pileup_model_path = file_path_from(file_name=args.pileup_model_path, exit_on_not_found=True, is_directory=False, allow_none=False)

    if args.enable_indel_calling:
        if args.indel_pileup_model_path is None:
            args.indel_pileup_model_path = os.path.join(args.conda_prefix, 'bin', 'tn_models', args.platform, 'indel',
                                                  'pileup.pkl')

        args.indel_pileup_model_path = file_path_from(file_name=args.indel_pileup_model_path, exit_on_not_found=True,
                                                is_directory=False, allow_none=False)

    default_gnomad_resource = os.path.join(args.conda_prefix, 'bin', 'databases',
                                           'gnomad.r2.1.af-ge-0.001.sites.vcf.gz')
    default_dbsnp_resource = os.path.join(args.conda_prefix, 'bin', 'databases',
                                          'dbsnp.b138.non-somatic.sites.vcf.gz')
    default_1kgpon_resource = os.path.join(args.conda_prefix, 'bin', 'databases', '1000g-pon.sites.vcf.gz')
    default_colorsdb_resource = os.path.join(args.conda_prefix, 'bin', 'databases', 'CoLoRSdb.GRCh38.v1.1.0.deepvariant.glnexus.af-ge-0.001.vcf.gz')

    default_gnomad_resource = file_path_from(file_name=default_gnomad_resource, exit_on_not_found=True,
                                             is_directory=False, allow_none=True)
    default_dbsnp_resource = file_path_from(file_name=default_dbsnp_resource, exit_on_not_found=True,
                                            is_directory=False, allow_none=True)
    default_1kgpon_resource = file_path_from(file_name=default_1kgpon_resource, exit_on_not_found=True,
                                             is_directory=False, allow_none=True)
    default_colorsdb_resource = file_path_from(file_name=default_colorsdb_resource, exit_on_not_found=True,
                                             is_directory=False, allow_none=True)

    if args.panel_of_normals is not None:
        if args.panel_of_normals == 'None' or args.panel_of_normals == 'Null' or args.panel_of_normals == ' ':
            args.disable_nonmosaic_tagging = True
        else:
            panel_of_normals_list = list(args.panel_of_normals.split(','))
            for pon in panel_of_normals_list:
                pon_path = file_path_from(file_name=str(pon), exit_on_not_found=True, is_directory=False,
                                          allow_none=True)
            if str(default_gnomad_resource) not in panel_of_normals_list:
                logging(log_warning(
                    "[INFO] Default {} PoN is not included!".format(str(default_gnomad_resource))))
            if str(default_dbsnp_resource) not in panel_of_normals_list:
                logging(log_warning(
                    "[INFO] Default {} PoN is not included!".format(str(default_dbsnp_resource))))
            if str(default_1kgpon_resource) not in panel_of_normals_list:
                logging(log_warning(
                    "[INFO] Default {} PoN is not included!".format(str(default_1kgpon_resource))))
            if str(default_colorsdb_resource) not in panel_of_normals_list:
                logging(log_warning(
                    "[INFO] Default {} PoN is not included!".format(str(default_colorsdb_resource))))
            args.panel_of_normals = args.panel_of_normals
            if args.panel_of_normals_require_allele_matching is not None:
                ori_panel_of_normals_require_allele_matching_list = list(args.panel_of_normals_require_allele_matching.split(','))
                if len(panel_of_normals_list) != len(ori_panel_of_normals_require_allele_matching_list):
                    logging(log_warning(
                        "[WARNING] Please use `--panel_of_normals_require_allele_matching` together with `--panel_of_normals`."))
                if args.panel_of_normals_require_allele_matching == 'None' or args.panel_of_normals_require_allele_matching == 'Null' or args.panel_of_normals_require_allele_matching == ' ':
                    panel_of_normals_require_allele_matching_list = ['True'] * len(panel_of_normals_list)
                    args.panel_of_normals_require_allele_matching = ','.join(panel_of_normals_require_allele_matching_list)
                else:
                    args.panel_of_normals_require_allele_matching = args.panel_of_normals_require_allele_matching
            else:
                panel_of_normals_require_allele_matching_list = ['True'] * len(panel_of_normals_list)
                args.panel_of_normals_require_allele_matching = ','.join(panel_of_normals_require_allele_matching_list)
    else:
        args.panel_of_normals = str(default_gnomad_resource) + ',' + str(default_dbsnp_resource) + ',' + str(
            default_1kgpon_resource) + ',' + str(default_colorsdb_resource)
        args.panel_of_normals_require_allele_matching = 'True' + ',' + 'True' + ',' + 'False' + ',' + 'False'

    default_gnomad_directory = os.path.join(args.conda_prefix, 'bin', 'databases', 'gnomad.r2.1.af-ge-0.00001_chr')

    if args.gnomad_dir is None:
        args.gnomad_dir = str(default_gnomad_directory)

    default_mosaicbase_resource = os.path.join(args.conda_prefix, 'bin', 'databases', 'MosaicBase.GRCh38.simplified.vcf.gz')
    default_mosaicbase_resource = file_path_from(file_name=default_mosaicbase_resource, exit_on_not_found=True,
                                             is_directory=False, allow_none=True)

    if args.mosaicbase_fn is None:
        args.mosaicbase_fn = str(default_mosaicbase_resource)

    default_cmrg_bed_resource = os.path.join(args.conda_prefix, 'bin', 'databases', 'CMRGv1.0.GRCh38.bed')
    default_cmrg_bed_resource = file_path_from(file_name=default_cmrg_bed_resource, exit_on_not_found=True,
                                             is_directory=False, allow_none=True)

    if args.call_variants_only_in_cmrg_bed_fn and args.cmrg_bed_fn is None:
        args.cmrg_bed_fn = str(default_cmrg_bed_resource)
    else:
        args.cmrg_bed_fn = None

    if args.snv_min_af is None:
        args.snv_min_af = param_tn.snv_min_af
    if args.indel_min_af is None:
        if args.enable_indel_calling:
            args.indel_min_af = 0.05
        else:
            args.indel_min_af = 1.0
    if args.min_coverage is None:
        args.min_coverage = param_tn.min_coverage
    if args.chunk_size is None:
        args.chunk_size = 5000000
    if args.platform not in set(extend_supported_platforms):
        logging(log_error('[ERROR] Invalid platform input, optional: {}'.format(', '.join(supported_platforms))))

    if args.qual is None:
        if args.prefer_balance:
            args.qual = param_tn.best_thred_qual[args.platform] if args.platform in param_tn.best_thred_qual else param_tn.best_thred_qual['ont']
        else:
            # default we enable min_thred_qual
            args.qual = param_tn.min_thred_qual[args.platform] if args.platform in param_tn.min_thred_qual else param_tn.min_thred_qual['ont']
    if args.skip_steps is not None:
        check_skip_steps_legal(args)

    if args.min_bq is None and (args.platform == "ont_r10_dorado_hac_5khz" or args.platform == "ont_r10_dorado_hac_4khz"):
        args.min_bq = 15

    if not args.enable_post_filtering:
        args.phase_input = False
    if args.disable_phasing or args.haplotagged_tumor_bam_provided_so_skip_intermediate_phasing_and_haplotagging:
        args.phase_input = False
    if args.phase_input is None:
        if args.genotyping_mode_vcf_fn is not None:
            logging(log_warning(
                "[WARNING] Clair3 HET SNPs based phasing is disabled if `--genotyping_mode_vcf_fn` is provided, add `--phase_input True` if phasing the input is still needed. Please ensure you have sufficient heterozygous variant candidates given in the --genotyping_mode_vcf_fn file, otherwise the phasing step might lead to worse performance."))
        else:
            args.phase_input = True if args.platform != 'ilmn' else False

    #N: normal V: variant T: tumor B: BAM
    NVNB = args.use_heterozygous_snp_in_normal_sample_and_normal_bam_for_intermediate_phasing
    TVTB = args.use_heterozygous_snp_in_tumor_sample_and_tumor_bam_for_intermediate_phasing
    NVTB = args.use_heterozygous_snp_in_normal_sample_and_tumor_bam_for_intermediate_phasing
    TVNB = args.use_heterozygous_snp_in_tumor_sample_and_normal_bam_for_intermediate_phasing

    # By default, we use HET SNP in normal VCF for phasing after v0.1.7
    if NVNB is None and TVTB is None and NVTB is None and TVNB is None:
        args.use_heterozygous_snp_in_normal_sample_and_tumor_bam_for_intermediate_phasing = True
        NVTB = True
    if NVTB:
        args.use_heterozygous_snp_in_normal_sample_for_intermediate_phasing = True
        args.use_normal_bam_for_intermediate_phasing = False
    elif TVNB:
        args.use_heterozygous_snp_in_tumor_sample_for_intermediate_phasing = True
        args.use_normal_bam_for_intermediate_phasing = True
    elif NVNB:
        args.use_heterozygous_snp_in_normal_sample_for_intermediate_phasing = True
        args.use_normal_bam_for_intermediate_phasing = True
    elif TVTB:
        args.use_heterozygous_snp_in_tumor_sample_for_intermediate_phasing = True
        args.use_normal_bam_for_intermediate_phasing = False

    if args.use_heterozygous_indel_for_intermediate_phasing is None:
        args.use_heterozygous_indel_for_intermediate_phasing = False

    if args.use_longphase_for_intermediate_haplotagging is None:
        args.use_longphase_for_intermediate_haplotagging = False

    if args.genotyping_mode_vcf_fn is not None or args.hybrid_mode_vcf_fn is not None:
        logging(log_warning("[INFO] Enable --print_ref_calls and --print_germline_calls options in genotyping mode!"))
        args.print_ref_calls = True
        args.print_germline_calls = True
        args.disable_print_nonmosaic_calls = False
        if args.hybrid_mode_vcf_fn is not None and args.platform != 'ilmn':
            logging(log_warning(
                "[INFO] Enable --enable_clair3_germline_output option in hybrid calling mode!"))

    if args.phase_input is False:
        # cannot only phase normal
        args.phase_control = False

    legal_range_from(param_name="threads", x=args.threads, min_num=1, exit_out_of_range=True)
    legal_range_from(param_name="qual", x=args.qual, min_num=-1, exit_out_of_range=True)
    legal_range_from(param_name="min_coverage", x=args.min_coverage, min_num=0, exit_out_of_range=True)
    legal_range_from(param_name="snv_min_af", x=args.snv_min_af, min_num=0, max_num=1, exit_out_of_range=True)
    legal_range_from(param_name="indel_min_af", x=args.indel_min_af, min_num=0, max_num=1, exit_out_of_range=True)
    if args.indel_max_af_in_normal is not None:
        legal_range_from(param_name="indel_max_af_in_normal", x=args.indel_max_af_in_normal, min_num=0, max_num=1, exit_out_of_range=True)
    legal_range_from(param_name="chunk_size", x=args.chunk_size, min_num=0, exit_out_of_range=True)

    args.output_path = create_output_folder_tn(args)
    check_tools_version(args=args)
    args = check_threads(args=args)
    if not args.platform.startswith('ilmn'):
        args = check_clair3_options(args)

    args = check_contigs_intersection_tn(args=args, fai_fn=fai_fn)

    return args


def check_args_to(args):
    if args.conda_prefix is None:
        if 'CONDA_PREFIX' in os.environ:
            args.conda_prefix = os.environ['CONDA_PREFIX']
        else:
            try:
                python_path = subprocess.run('which python', stdout=subprocess.PIPE,
                                             shell=True).stdout.decode().rstrip()
                args.conda_prefix = os.path.dirname(os.path.dirname(python_path))
            except:
                sys.exit(log_error("[ERROR] Conda prefix not found, please activate a correct conda environment."))

    args.bam_fn = file_path_from(file_name=args.bam_fn, exit_on_not_found=True)
    tumor_bai_fn = file_path_from(file_name=args.bam_fn, suffix=".bai", exit_on_not_found=False, sep='.')
    tumor_crai_fn = file_path_from(file_name=args.bam_fn, suffix=".crai", exit_on_not_found=False, sep='.')
    tumor_csi_fn = file_path_from(file_name=args.bam_fn, suffix=".csi", exit_on_not_found=False, sep='.')

    args.ref_fn = file_path_from(file_name=args.ref_fn, exit_on_not_found=True)
    fai_fn = file_path_from(file_name=args.ref_fn, suffix=".fai", exit_on_not_found=True, sep='.')
    args.bed_fn = file_path_from(file_name=args.bed_fn, exit_on_not_found=True, allow_none=True)
    args.genotyping_mode_vcf_fn = file_path_from(file_name=args.genotyping_mode_vcf_fn, exit_on_not_found=True,
                                                 allow_none=True)
    args.hybrid_mode_vcf_fn = file_path_from(file_name=args.hybrid_mode_vcf_fn, exit_on_not_found=True, allow_none=True)

    if args.platform in param_to.model_name_platform_dict:
        updated_platform = param_to.model_name_platform_dict[args.platform]
        logging(
            "[INFO] Platform parameter is using ONT model name format, change --platform {} to --platform {}".format(
                args.platform, updated_platform))
        args.platform = updated_platform

    if tumor_bai_fn is None and tumor_crai_fn is None and tumor_csi_fn is None:
        sys.exit(log_error(
            "[ERROR] Input BAM index file {} or {} not found. Please run `samtools index $BAM` first.".format(
                args.bam_fn + '.bai',
                args.bam_fn + '.crai')))

    if args.enable_indel_calling and args.platform not in {'ont_r10_dorado_sup_4khz', 'ont_r10_dorado_hac_4khz', 'ont_r10_dorado_sup_5khz',
                             'ont_r10_guppy_sup_4khz', 'ont_r10_guppy_hac_5khz', 'ont_r10_dorado_4khz',
                             'ont_r10_dorado_5khz', 'ont_r10_guppy', 'ont_r10_guppy_4khz', 'ont_r10_guppy_5khz', 'ilmn', 'hifi_revio'}:
        sys.exit(log_error("[ERROR] Indel calling only support 'ont_r10_dorado_sup_4khz', 'ont_r10_dorado_hac_4khz', 'ont_r10_dorado_sup_5khz', 'ont_r10_guppy_sup_4khz', 'ont_r10_guppy_hac_5khz', 'ilmn', and 'hifi_revio' platform"))

    if args.genotyping_mode_vcf_fn is not None and args.hybrid_mode_vcf_fn is not None:
        sys.exit(log_error("[ERROR] Please provide either --genotyping_mode_vcf_fn or --hybrid_mode_vcf_fn only"))

    if args.snv_pileup_affirmative_model_path is None:
        if args.platform == 'ont_r10_guppy_sup_4khz' or args.platform == 'ont_r10_guppy_4khz' or args.platform == 'ont_r10_guppy':
            args.snv_pileup_affirmative_model_path = os.path.join(args.conda_prefix, 'bin', 'to_models',
                                                              'ont_r10_guppy_sup_4khz', 'pileup_affirmative.pkl')
        elif args.platform == 'ont_r10_dorado_sup_5khz' or args.platform == 'ont_r10_dorado_5khz':
            args.snv_pileup_affirmative_model_path = os.path.join(args.conda_prefix, 'bin', 'to_models',
                                                              'ont_r10_dorado_sup_5khz', 'pileup_affirmative.pkl')
        elif args.platform == 'ont_r10_dorado_sup_4khz' or args.platform == 'ont_r10_dorado_4khz':
            args.snv_pileup_affirmative_model_path = os.path.join(args.conda_prefix, 'bin', 'to_models',
                                                              'ont_r10_dorado_sup_4khz', 'pileup_affirmative.pkl')
        elif args.platform == 'ont_r10_dorado_hac_4khz':
            args.snv_pileup_affirmative_model_path = os.path.join(args.conda_prefix, 'bin', 'to_models',
                                                              'ont_r10_dorado_hac_4khz', 'pileup_affirmative.pkl')
        elif args.platform == 'ont_r10_guppy_hac_5khz' or args.platform == 'ont_r10_guppy_5khz':
            args.snv_pileup_affirmative_model_path = os.path.join(args.conda_prefix, 'bin', 'to_models',
                                                              'ont_r10_guppy_hac_5khz', 'pileup_affirmative.pkl')
        elif args.platform == 'ilmn':
            args.snv_pileup_affirmative_model_path = os.path.join(args.conda_prefix, 'bin', 'to_models',
                                                              'ilmn', 'pileup_affirmative.pkl')
        elif args.platform == 'hifi_revio':
            args.snv_pileup_affirmative_model_path = os.path.join(args.conda_prefix, 'bin', 'to_models',
                                                              'hifi_revio', 'pileup_affirmative.pkl')
        else:
            args.snv_pileup_affirmative_model_path = os.path.join(args.conda_prefix, 'bin', 'to_models',
                                                              args.platform, 'pileup_affirmative.pkl')

    args.snv_pileup_affirmative_model_path = file_path_from(file_name=args.snv_pileup_affirmative_model_path,
                                                        exit_on_not_found=True, is_directory=False, allow_none=False)

    if args.enable_indel_calling:
        if args.indel_pileup_affirmative_model_path is None:
            if args.platform == 'ont_r10_guppy_sup_4khz' or args.platform == 'ont_r10_guppy_4khz' or args.platform == 'ont_r10_guppy':
                args.indel_pileup_affirmative_model_path = os.path.join(args.conda_prefix, 'bin', 'to_models',
                                                                  'ont_r10_guppy_sup_4khz', 'indel', 'pileup_affirmative.pkl')
            elif args.platform == 'ont_r10_dorado_sup_5khz' or args.platform == 'ont_r10_dorado_5khz':
                args.indel_pileup_affirmative_model_path = os.path.join(args.conda_prefix, 'bin', 'to_models',
                                                                  'ont_r10_dorado_sup_5khz', 'indel', 'pileup_affirmative.pkl')
            elif args.platform == 'ont_r10_dorado_sup_4khz' or args.platform == 'ont_r10_dorado_4khz':
                args.indel_pileup_affirmative_model_path = os.path.join(args.conda_prefix, 'bin', 'to_models',
                                                                  'ont_r10_dorado_sup_4khz', 'indel', 'pileup_affirmative.pkl')
            elif args.platform == 'ont_r10_dorado_hac_4khz':
                args.indel_pileup_affirmative_model_path = os.path.join(args.conda_prefix, 'bin', 'to_models',
                                                                  'ont_r10_dorado_hac_4khz', 'indel', 'pileup_affirmative.pkl')
            elif args.platform == 'ont_r10_guppy_hac_5khz' or args.platform == 'ont_r10_guppy_5khz':
                args.indel_pileup_affirmative_model_path = os.path.join(args.conda_prefix, 'bin', 'to_models',
                                                                  'ont_r10_guppy_hac_5khz', 'indel', 'pileup_affirmative.pkl')
            elif args.platform == 'ilmn':
                args.indel_pileup_affirmative_model_path = os.path.join(args.conda_prefix, 'bin', 'to_models',
                                                                  'ilmn', 'indel', 'pileup_affirmative.pkl')
            elif args.platform == 'hifi_revio':
                args.indel_pileup_affirmative_model_path = os.path.join(args.conda_prefix, 'bin', 'to_models',
                                                                  'hifi_revio', 'indel', 'pileup_affirmative.pkl')
            else:
                args.indel_pileup_affirmative_model_path = os.path.join(args.conda_prefix, 'bin', 'to_models',
                                                                  args.platform, 'indel', 'pileup_affirmative.pkl')

        args.indel_pileup_affirmative_model_path = file_path_from(file_name=args.indel_pileup_affirmative_model_path, exit_on_not_found=True,
                                                is_directory=False, allow_none=False)

    default_gnomad_resource = os.path.join(args.conda_prefix, 'bin', 'databases',
                                           'gnomad.r2.1.af-ge-0.001.sites.vcf.gz')
    default_dbsnp_resource = os.path.join(args.conda_prefix, 'bin', 'databases',
                                          'dbsnp.b138.non-somatic.sites.vcf.gz')
    default_1kgpon_resource = os.path.join(args.conda_prefix, 'bin', 'databases', '1000g-pon.sites.vcf.gz')
    default_colorsdb_resource = os.path.join(args.conda_prefix, 'bin', 'databases', 'CoLoRSdb.GRCh38.v1.1.0.deepvariant.glnexus.af-ge-0.001.vcf.gz')

    default_gnomad_resource = file_path_from(file_name=default_gnomad_resource, exit_on_not_found=True,
                                             is_directory=False, allow_none=True)
    default_dbsnp_resource = file_path_from(file_name=default_dbsnp_resource, exit_on_not_found=True,
                                            is_directory=False, allow_none=True)
    default_1kgpon_resource = file_path_from(file_name=default_1kgpon_resource, exit_on_not_found=True,
                                             is_directory=False, allow_none=True)
    default_colorsdb_resource = file_path_from(file_name=default_colorsdb_resource, exit_on_not_found=True,
                                             is_directory=False, allow_none=True)

    if args.panel_of_normals is not None:
        if args.panel_of_normals == 'None' or args.panel_of_normals == 'Null' or args.panel_of_normals == ' ':
            args.disable_nonmosaic_tagging = True
        else:
            panel_of_normals_list = list(args.panel_of_normals.split(','))
            for pon in panel_of_normals_list:
                pon_path = file_path_from(file_name=str(pon), exit_on_not_found=True, is_directory=False,
                                          allow_none=True)
            if str(default_gnomad_resource) not in panel_of_normals_list:
                logging(log_warning(
                    "[INFO] Default {} PoN is not included!".format(str(default_gnomad_resource))))
            if str(default_dbsnp_resource) not in panel_of_normals_list:
                logging(log_warning(
                    "[INFO] Default {} PoN is not included!".format(str(default_dbsnp_resource))))
            if str(default_1kgpon_resource) not in panel_of_normals_list:
                logging(log_warning(
                    "[INFO] Default {} PoN is not included!".format(str(default_1kgpon_resource))))
            if str(default_colorsdb_resource) not in panel_of_normals_list:
                logging(log_warning(
                    "[INFO] Default {} PoN is not included!".format(str(default_colorsdb_resource))))
            args.panel_of_normals = args.panel_of_normals
            if args.panel_of_normals_require_allele_matching is not None:
                ori_panel_of_normals_require_allele_matching_list = list(args.panel_of_normals_require_allele_matching.split(','))
                if len(panel_of_normals_list) != len(ori_panel_of_normals_require_allele_matching_list):
                    logging(log_warning(
                        "[WARNING] Please use `--panel_of_normals_require_allele_matching` together with `--panel_of_normals`."))
                if args.panel_of_normals_require_allele_matching == 'None' or args.panel_of_normals_require_allele_matching == 'Null' or args.panel_of_normals_require_allele_matching == ' ':
                    panel_of_normals_require_allele_matching_list = ['True'] * len(panel_of_normals_list)
                    args.panel_of_normals_require_allele_matching = ','.join(panel_of_normals_require_allele_matching_list)
                else:
                    args.panel_of_normals_require_allele_matching = args.panel_of_normals_require_allele_matching
            else:
                panel_of_normals_require_allele_matching_list = ['True'] * len(panel_of_normals_list)
                args.panel_of_normals_require_allele_matching = ','.join(panel_of_normals_require_allele_matching_list)
    else:
        args.panel_of_normals = str(default_gnomad_resource) + ',' + str(default_dbsnp_resource) + ',' + str(
            default_1kgpon_resource) + ',' + str(default_colorsdb_resource)
        args.panel_of_normals_require_allele_matching = 'True' + ',' + 'True' + ',' + 'False' + ',' + 'False'

    default_gnomad_directory = os.path.join(args.conda_prefix, 'bin', 'databases', 'gnomad.r2.1.af-ge-0.00001_chr')

    if args.gnomad_dir is None:
        args.gnomad_dir = str(default_gnomad_directory)

    default_mosaicbase_resource = os.path.join(args.conda_prefix, 'bin', 'databases', 'MosaicBase.GRCh38.simplified.vcf.gz')
    default_mosaicbase_resource = file_path_from(file_name=default_mosaicbase_resource, exit_on_not_found=True,
                                             is_directory=False, allow_none=True)

    if args.mosaicbase_fn is None:
        args.mosaicbase_fn = str(default_mosaicbase_resource)

    default_cmrg_bed_resource = os.path.join(args.conda_prefix, 'bin', 'databases', 'CMRGv1.0.GRCh38.bed')
    default_cmrg_bed_resource = file_path_from(file_name=default_cmrg_bed_resource, exit_on_not_found=True,
                                             is_directory=False, allow_none=True)

    if args.call_variants_only_in_cmrg_bed_fn and args.cmrg_bed_fn is None:
        args.cmrg_bed_fn = str(default_cmrg_bed_resource)
    else:
        args.cmrg_bed_fn = None

    if args.bed_fn is not None and args.call_indels_only_in_these_regions is not None:
        logging(log_warning(
            "[WARNING] `--bed_fn` will supersede `--call_indels_only_in_these_regions`."))

    if args.whatshap is None:
        args.whatshap = os.path.join(args.conda_prefix, 'bin', 'whatshap')
    if args.longphase is None:
        args.longphase = os.path.join(args.conda_prefix, 'bin', 'longphase')
    args.use_longphase_for_intermediate_phasing = False if args.use_whatshap_for_intermediate_phasing is True else True
    if args.use_longphase_for_intermediate_phasing and not os.path.exists(args.longphase):
        sys.exit(log_error("[ERROR] Cannot find longphase at {}".format(args.longphase)))
    if args.use_whatshap_for_intermediate_phasing and not os.path.exists(args.whatshap):
        sys.exit(log_error("[ERROR] Cannot find whatshap at {}".format(args.whatshap)))
    if args.use_longphase_for_intermediate_haplotagging is None:
        args.use_longphase_for_intermediate_haplotagging = True
    if args.use_longphase_for_intermediate_haplotagging and not os.path.exists(args.longphase):
        sys.exit(log_error("[ERROR] Cannot find longphase at {}".format(args.longphase)))

    if args.snv_min_af is None:
        args.snv_min_af = param_to.snv_min_af
    if args.indel_min_af is None:
        if args.enable_indel_calling:
            args.indel_min_af = 0.05
        else:
            args.indel_min_af = 1.0
    if args.min_coverage is None:
        args.min_coverage = param_to.min_coverage
    if args.chunk_size is None:
        args.chunk_size = 5000000

    if args.min_bq is None:
        args.min_bq = param_to.min_bq_dict[args.platform]

    if args.platform not in {'ont_r10_dorado_sup_4khz', 'ont_r10_dorado_hac_4khz', 'ont_r10_dorado_sup_5khz',
                             'ont_r10_guppy_sup_4khz', 'ont_r10_guppy_hac_5khz', 'ont_r10_dorado_4khz',
                             'ont_r10_dorado_5khz', 'ont_r10_guppy', 'ont_r10_guppy_4khz', 'ont_r10_guppy_5khz', 'ilmn', 'hifi_revio'}:
        logging(log_error(
            '[ERROR] Invalid platform input, optional: {ont_r10_dorado_sup_4khz, ont_r10_dorado_hac_4khz, ont_r10_dorado_sup_5khz, ont_r10_guppy_sup_4khz, ont_r10_guppy_hac_5khz, ilmn, hifi_revio}'))

    if args.qual is None:
        args.qual = param_to.min_thred_qual[args.platform] if args.platform in param_to.min_thred_qual else param_to.min_thred_qual['ont']
        if args.qual_cutoff_phaseable_region is None:
            args.qual_cutoff_phaseable_region = param_to.min_phaseable_thred_qual[
                args.platform] if args.platform in param_to.min_phaseable_thred_qual else \
                param_to.min_phaseable_thred_qual['ont']
        if args.qual_cutoff_unphaseable_region is None:
            args.qual_cutoff_unphaseable_region = param_to.min_unphaseable_thred_qual[
                args.platform] if args.platform in param_to.min_unphaseable_thred_qual else \
                param_to.min_unphaseable_thred_qual['ont']
        args.qual_indel = param_to.min_thred_qual_indel[args.platform] if args.platform in param_to.min_thred_qual_indel else \
            param_to.min_thred_qual_indel['ont']
        if args.qual_indel_cutoff_phaseable_region is None:
            args.qual_indel_cutoff_phaseable_region = param_to.min_phaseable_thred_qual_indel[
                args.platform] if args.platform in param_to.min_phaseable_thred_qual_indel else \
                param_to.min_phaseable_thred_qual_indel['ont']
        if args.qual_indel_cutoff_unphaseable_region is None:
            args.qual_indel_cutoff_unphaseable_region = param_to.min_unphaseable_thred_qual_indel[
                args.platform] if args.platform in param_to.min_unphaseable_thred_qual_indel else \
                param_to.min_unphaseable_thred_qual_indel['ont']
    else:
        if args.qual_cutoff_phaseable_region is not None or args.qual_cutoff_unphaseable_region is not None:
            logging(log_warning(
                "[WARNING] `--qual` will supersede `--qual_cutoff_phaseable_region` and `--qual_cutoff_unphaseable_region`."))
        args.qual_cutoff_phaseable_region = args.qual
        args.qual_cutoff_unphaseable_region = args.qual
        args.qual_indel = args.qual
        args.qual_indel_cutoff_phaseable_region = args.qual
        args.qual_indel_cutoff_unphaseable_region = args.qual
    if args.skip_steps is not None:
        check_skip_steps_legal(args)

    if not args.enable_post_filtering:
        args.phase_input = False
    if args.disable_intermediate_phasing:
        args.phase_input = False
    if args.phase_input is None:
        if args.genotyping_mode_vcf_fn is not None:
            logging(log_warning(
                "[WARNING] HET SNPs based phasing is disabled if `--genotyping_mode_vcf_fn` is provided, add `--phase_input True` if phasing the input is still needed. Please ensure you have sufficient heterozygous variant candidates given in the --genotyping_mode_vcf_fn file, otherwise the phasing step might lead to worse performance."))
        else:
            args.phase_input = True if args.platform != 'ilmn' else False

    if args.genotyping_mode_vcf_fn is not None or args.hybrid_mode_vcf_fn is not None:
        logging(log_warning(
            "[INFO] Enable --print_ref_calls option and disable --disable_print_nonmosaic_calls in genotyping mode!"))
        args.print_ref_calls = True
        args.disable_print_nonmosaic_calls = False
        args.enable_indel_calling = False

    legal_range_from(param_name="threads", x=args.threads, min_num=1, exit_out_of_range=True)
    legal_range_from(param_name="qual", x=args.qual, min_num=0, exit_out_of_range=True)
    legal_range_from(param_name="qual_cutoff_phaseable_region", x=args.qual_cutoff_phaseable_region, min_num=0, exit_out_of_range=True)
    legal_range_from(param_name="qual_cutoff_unphaseable_region", x=args.qual_cutoff_unphaseable_region, min_num=0, exit_out_of_range=True)
    legal_range_from(param_name="min_coverage", x=args.min_coverage, min_num=0, exit_out_of_range=True)
    legal_range_from(param_name="min_bq", x=args.min_bq, min_num=0, exit_out_of_range=True)
    legal_range_from(param_name="snv_min_af", x=args.snv_min_af, min_num=0, max_num=1, exit_out_of_range=True)
    legal_range_from(param_name="indel_min_af", x=args.indel_min_af, min_num=0, max_num=1, exit_out_of_range=True)
    legal_range_from(param_name="chunk_size", x=args.chunk_size, min_num=0, exit_out_of_range=True)

    args.output_path = create_output_folder_to(args)
    check_tools_version(args=args)
    args = check_threads(args=args)
    args = check_contigs_intersection_to(args=args, fai_fn=fai_fn)

    return args


def print_args_tn(args):
    logging("")
    logging("[INFO] CALLER VERSION: {}".format(param_tn.version))
    logging("[INFO] INPUT BAM FILE PATH: {}".format(args.bam_fn))
    logging("[INFO] CONTROL BAM FILE PATH: {}".format(args.control_bam_fn))
    logging("[INFO] REFERENCE FILE PATH: {}".format(args.ref_fn))
    logging("[INFO] PLATFORM: {}".format(args.platform))
    logging("[INFO] THREADS: {}".format(args.threads))
    logging("[INFO] OUTPUT FOLDER: {}".format(args.output_dir))
    logging("[INFO] OUTPUT VCF PATH: {}".format(os.path.join(args.output_dir, args.output_prefix + '.vcf.gz')))
    logging("[INFO] PILEUP MODEL PATH: {}".format(args.pileup_model_path))
    logging("[INFO] BED FILE PATH: {}".format(args.bed_fn))
    logging("[INFO] GENOTYPING MODE VCF FILE PATH: {}".format(args.genotyping_mode_vcf_fn))
    logging("[INFO] HYBRID MODE VCF FILE PATH: {}".format(args.hybrid_mode_vcf_fn))
    logging("[INFO] PANEL OF NORMALS: {}".format(args.panel_of_normals))
    logging("[INFO] PANEL OF NORMALS REQUIRE ALLELE MATCHING: {}".format(args.panel_of_normals_require_allele_matching))
    logging("[INFO] MOSAICBASE PATH: {}".format(args.mosaicbase_fn))
    logging("[INFO] REGION FOR CALLING: {}".format(args.region))
    logging("[INFO] CONTIGS FOR CALLING: {}".format(args.ctg_name))
    logging("[INFO] CONDA BINARY PREFIX: {}".format(args.conda_prefix))
    logging("[INFO] SAMTOOLS BINARY PATH: {}".format(args.samtools))
    logging("[INFO] PYTHON BINARY PATH: {}".format(args.python))
    logging("[INFO] PYPY BINARY PATH: {}".format(args.pypy))
    logging("[INFO] PARALLEL BINARY PATH: {}".format(args.parallel))
    logging("[INFO] CHUNK SIZE: {}".format(args.chunk_size))
    logging("[INFO] SNV MINIMUM AF: {}".format(args.snv_min_af))
    if args.enable_indel_calling:
        logging("[INFO] INDEL MINIMUM AF: {}".format(args.indel_min_af))
        logging("[INFO] INDEL PILEUP MODEL PATH: {}".format(args.indel_pileup_model_path))
    logging("[INFO] CONTROL VCF FILE PATH: {}".format(args.normal_vcf_fn))
    logging("[INFO] ENABLE DRY RUN: {}".format(args.dry_run))
    logging("[INFO] ENABLE INDEL CALLING: {}".format(args.enable_indel_calling))
    logging("[INFO] ENABLE PRINTING REFERENCE CALLS: {}".format(args.print_ref_calls))
    logging("[INFO] ENABLE PRINTING GERMLINE CALLS: {}".format(args.print_germline_calls))
    logging("[INFO] ENABLE INCLUDING ALL CTGS FOR CALLING: {}".format(args.include_all_ctgs))
    logging("[INFO] ENABLE REMOVING INTERMEDIATE FILES: {}".format(args.remove_intermediate_dir))
    logging("[INFO] ENABLE APPLYING NON-MOSAIC TAGGING: {}".format(not args.disable_nonmosaic_tagging))
    logging("[INFO] ENABLE APPLYING BAYMGD TAGGING: {}".format(args.enable_baymgd_tagging))
    logging("[INFO] ENABLE APPLYING MOSAICBASE TAGGING: {}".format(args.enable_mosaicbase_tagging))
    logging("[INFO] ENABLE APPLYING POST FILTERING: {}".format(args.enable_post_filtering))
    logging("")

    if args.platform.startswith('ilmn'):
        args.platform = 'ilmn'

    if args.platform.startswith('ont'):
        args.platform = 'ont'

    if args.platform.startswith('hifi'):
        args.platform = 'hifi'

    if args.cmdline is not None and args.cmdline != "":
        with open(args.output_dir + '/tmp/CMD', 'w') as f:
            f.write(args.cmdline + '\n')

    return args


def print_args_to(args):
    logging("")
    logging("[INFO] CALLER VERSION: {}".format(param_to.version))
    logging("[INFO] INPUT BAM FILE PATH: {}".format(args.bam_fn))
    logging("[INFO] REFERENCE FILE PATH: {}".format(args.ref_fn))
    logging("[INFO] PLATFORM: {}".format(args.platform))
    logging("[INFO] THREADS: {}".format(args.threads))
    logging("[INFO] OUTPUT FOLDER: {}".format(args.output_dir))
    logging("[INFO] SNV OUTPUT VCF PATH: {}".format(os.path.join(args.output_dir, args.snv_output_prefix + '.vcf.gz')))
    logging("[INFO] INDEL OUTPUT VCF PATH: {}".format(os.path.join(args.output_dir, args.indel_output_prefix + '.vcf.gz')))
    logging("[INFO] SNV MINIMUM AF: {}".format(args.snv_min_af))
    logging("[INFO] INDEL MINIMUM AF: {}".format(args.indel_min_af))
    logging("[INFO] SNV PILEUP AFFIRMATIVE MODEL PATH: {}".format(args.snv_pileup_affirmative_model_path))
    logging("[INFO] INDEL PILEUP AFFIRMATIVE MODEL PATH: {}".format(args.indel_pileup_affirmative_model_path))
    logging("[INFO] BED FILE PATH: {}".format(args.bed_fn))
    logging("[INFO] SPECIFIED REGIONS FOR CALLING: {}".format(args.region))
    logging("[INFO] CONTIGS FOR CALLING: {}".format(args.ctg_name))
    logging("[INFO] ENABLE INCLUDING ALL CTGS FOR CALLING: {}".format(args.include_all_ctgs))
    logging("[INFO] GENOTYPING MODE VCF FILE PATH: {}".format(args.genotyping_mode_vcf_fn))
    logging("[INFO] HYBRID MODE VCF FILE PATH: {}".format(args.hybrid_mode_vcf_fn))
    logging("[INFO] PANEL OF NORMALS: {}".format(args.panel_of_normals))
    logging("[INFO] PANEL OF NORMALS REQUIRE ALLELE MATCHING: {}".format(args.panel_of_normals_require_allele_matching))
    logging("[INFO] MOSAICBASE PATH: {}".format(args.mosaicbase_fn))
    logging("[INFO] CHUNK SIZE: {}".format(args.chunk_size))
    logging("[INFO] CONDA BINARY PREFIX: {}".format(args.conda_prefix))
    logging("[INFO] SAMTOOLS BINARY PATH: {}".format(args.samtools))
    logging("[INFO] PYTHON BINARY PATH: {}".format(args.python))
    logging("[INFO] PYPY BINARY PATH: {}".format(args.pypy))
    logging("[INFO] PARALLEL BINARY PATH: {}".format(args.parallel))
    logging("[INFO] LONGPHASE BINARY PATH: {}".format(args.longphase))
    logging("[INFO] WHATSHAP BINARY PATH: {}".format(args.whatshap))
    logging("[INFO] ENABLE DRY RUN: {}".format(args.dry_run))
    logging("[INFO] ENABLE REMOVING INTERMEDIATE FILES: {}".format(args.remove_intermediate_dir))
    logging("[INFO] ENABLE INDEL CALLING: {}".format(args.enable_indel_calling))
    logging("[INFO] ENABLE PRINTING REFERENCE CALLS: {}".format(args.print_ref_calls))
    logging("[INFO] ENABLE APPLYING NON-MOSAIC TAGGING: {}".format(not args.disable_nonmosaic_tagging))
    logging("[INFO] ENABLE APPLYING BAYMGD TAGGING: {}".format(args.enable_baymgd_tagging))
    logging("[INFO] ENABLE APPLYING MOSAICBASE TAGGING: {}".format(args.enable_mosaicbase_tagging))
    logging("[INFO] ENABLE APPLYING POST FILTERING: {}".format(args.enable_post_filtering))
    logging("")

    if args.platform.startswith('ont'):
        args.platform = 'ont'

    if args.platform.startswith('hifi'):
        args.platform = 'hifi'

    if args.platform.startswith('ilmn'):
        args.platform = 'ilmn'

    if args.cmdline is not None and args.cmdline != "":
        with open(args.output_dir + '/tmp/CMD', 'w') as f:
            f.write(args.cmdline + '\n')

    return args


def print_command_line_tn(args):
    try:
        cmdline = os.path.realpath(__file__)
        cmdline += ' --bam_fn {} '.format(args.bam_fn)
        cmdline += '--control_bam_fn {} '.format(args.control_bam_fn)
        cmdline += '--ref_fn {} '.format(args.ref_fn)
        cmdline += '--threads {} '.format(args.threads)
        cmdline += '--platform {} '.format(args.platform)
        cmdline += '--output_dir {} '.format(args.output_dir)
        cmdline += '--pileup_model_path {} '.format(args.pileup_model_path) if args.pileup_model_path is not None else ""
        cmdline += '--ctg_name {} '.format(args.ctg_name) if args.ctg_name is not None else ""
        cmdline += '--region {} '.format(args.region) if args.region is not None else ""
        cmdline += '--bed_fn {} '.format(args.bed_fn) if args.bed_fn is not None else ""
        cmdline += '--genotyping_mode_vcf_fn {} '.format(args.genotyping_mode_vcf_fn) if args.genotyping_mode_vcf_fn is not None else ""
        cmdline += '--hybrid_mode_vcf_fn {} '.format(args.hybrid_mode_vcf_fn) if args.hybrid_mode_vcf_fn is not None else ""
        cmdline += '--qual {} '.format(args.qual) if args.qual is not None else ""
        cmdline += '--snv_min_af {} '.format(args.snv_min_af) if args.snv_min_af is not None else ""
        cmdline += '--indel_min_af {} '.format(args.indel_min_af) if args.indel_min_af is not None else ""
        cmdline += '--indel_max_af_in_normal {} '.format(args.indel_max_af_in_normal) if args.indel_max_af_in_normal is not None else ""
        cmdline += '--min_coverage {} '.format(args.min_coverage) if args.min_coverage is not None else ""
        cmdline += '--chunk_size {} '.format(args.chunk_size) if args.chunk_size is not None else ""
        cmdline += '--sample_name {} '.format(args.sample_name) if args.sample_name != "SAMPLE" else ""
        cmdline += '--output_prefix {} '.format(args.output_prefix) if args.output_prefix != "output" else ""
        cmdline += '--remove_intermediate_dir ' if args.remove_intermediate_dir else ""
        cmdline += '--panel_of_normals {} '.format(args.panel_of_normals) if args.panel_of_normals is not None else ""
        cmdline += '--panel_of_normals_require_allele_matching {} '.format(args.panel_of_normals_require_allele_matching) if args.panel_of_normals_require_allele_matching is not None else ""
        cmdline += '--include_all_ctgs ' if args.include_all_ctgs else ""
        cmdline += '--print_ref_calls ' if args.print_ref_calls else ""
        cmdline += '--print_germline_calls ' if args.print_germline_calls else ""
        cmdline += '--python {} '.format(args.python) if args.python != "python3" else ""
        cmdline += '--pypy {} '.format(args.pypy) if args.pypy != "pypy3" else ""
        cmdline += '--samtools {} '.format(args.samtools) if args.samtools != "samtools" else ""
        cmdline += '--parallel {} '.format(args.parallel) if args.parallel != "parallel" else ""
        cmdline += '--normal_vcf_fn {} '.format(args.normal_vcf_fn) if args.normal_vcf_fn is not None else ""
        cmdline += '--disable_phasing ' if args.disable_phasing else ""
        cmdline += '--haplotagged_tumor_bam_provided_so_skip_intermediate_phasing_and_haplotagging ' if args.haplotagged_tumor_bam_provided_so_skip_intermediate_phasing_and_haplotagging else ""
        cmdline += '--clair3_path {} '.format(args.clair3_path) if args.clair3_path is not None else ""
        cmdline += '--clair3_model_path {} '.format(args.clair3_model_path) if args.clair3_model_path is not None else ""
        cmdline += '--longphase {} '.format(args.longphase) if args.longphase is not None else ""
        cmdline += '--whatshap {} '.format(args.whatshap) if args.whatshap is not None else ""
        cmdline += '--whatshap_for_phasing {} '.format(args.whatshap_for_phasing) if args.whatshap_for_phasing is not None else ""
        cmdline += '--enable_indel_calling ' if args.enable_indel_calling else ""
        cmdline += '--indel_output_prefix {} '.format(args.indel_output_prefix) if args.indel_output_prefix != "indel" else ""
        cmdline += '--indel_pileup_model_path {} '.format(args.indel_pileup_model_path) if args.indel_pileup_model_path is not None else ""
        cmdline += '--prefer_recall ' if args.prefer_recall else ""
        cmdline += '--prefer_balance ' if args.prefer_balance else ""
        cmdline += '--phase_control {} '.format(args.phase_control) if args.phase_control is True else ""
        cmdline += '--phase_input {} '.format(args.phase_input) if args.phase_input is not None else ""
        cmdline += '--clair3_min_coverage {} '.format(args.clair3_min_coverage) if args.clair3_min_coverage is not None else ""
        cmdline += '--clair3_snp_min_af {} '.format(args.clair3_snp_min_af) if args.clair3_snp_min_af is not None else ""
        cmdline += '--clair3_indel_min_af {} '.format(args.clair3_indel_min_af) if args.clair3_indel_min_af is not None else ""
        cmdline += '--enable_clair3_germline_output ' if args.enable_clair3_germline_output else ""
        cmdline += '--use_heterozygous_snp_in_normal_sample_and_normal_bam_for_intermediate_phasing {} '.format(args.use_heterozygous_snp_in_normal_sample_and_normal_bam_for_intermediate_phasing) if args.use_heterozygous_snp_in_normal_sample_and_normal_bam_for_intermediate_phasing is not None else ""
        cmdline += '--use_heterozygous_snp_in_tumor_sample_and_tumor_bam_for_intermediate_phasing {} '.format(args.use_heterozygous_snp_in_tumor_sample_and_tumor_bam_for_intermediate_phasing) if args.use_heterozygous_snp_in_tumor_sample_and_tumor_bam_for_intermediate_phasing is not None else ""
        cmdline += '--use_heterozygous_snp_in_normal_sample_and_tumor_bam_for_intermediate_phasing {} '.format(args.use_heterozygous_snp_in_normal_sample_and_tumor_bam_for_intermediate_phasing) if args.use_heterozygous_snp_in_normal_sample_and_tumor_bam_for_intermediate_phasing is not None else ""
        cmdline += '--use_heterozygous_snp_in_tumor_sample_and_normal_bam_for_intermediate_phasing {} '.format(args.use_heterozygous_snp_in_tumor_sample_and_normal_bam_for_intermediate_phasing) if args.use_heterozygous_snp_in_tumor_sample_and_normal_bam_for_intermediate_phasing is not None else ""
        cmdline += '--use_heterozygous_snp_in_normal_sample_for_intermediate_phasing {} '.format(args.use_heterozygous_snp_in_normal_sample_for_intermediate_phasing) if args.use_heterozygous_snp_in_normal_sample_for_intermediate_phasing is not None else ""
        cmdline += '--use_heterozygous_snp_in_tumor_sample_for_intermediate_phasing {} '.format(args.use_heterozygous_snp_in_tumor_sample_for_intermediate_phasing) if args.use_heterozygous_snp_in_tumor_sample_for_intermediate_phasing is not None else ""
        cmdline += '--use_heterozygous_indel_for_intermediate_phasing {} '.format(args.use_heterozygous_indel_for_intermediate_phasing) if args.use_heterozygous_indel_for_intermediate_phasing is not None else ""
        cmdline += '--use_normal_bam_for_intermediate_phasing {} '.format(args.use_normal_bam_for_intermediate_phasing) if args.use_normal_bam_for_intermediate_phasing is not None else ""
        cmdline += '--use_longphase_for_intermediate_haplotagging {} '.format(args.use_longphase_for_intermediate_haplotagging) if args.use_longphase_for_intermediate_haplotagging is not None else ""
        cmdline += '--use_gpu ' if args.use_gpu else ""
        cmdline += '--indel_min_af {} '.format(args.indel_min_af) if args.indel_min_af is not None else ""
        cmdline += '--skip_steps {} '.format(args.skip_steps) if args.skip_steps is not None else ""
        cmdline += '--conda_prefix {} '.format(args.conda_prefix) if args.conda_prefix is not None else ""
        cmdline += '--disable_nonmosaic_tagging ' if args.disable_nonmosaic_tagging else ""
        cmdline += '--enable_baymgd_tagging ' if args.enable_baymgd_tagging else ""
        cmdline += '--enable_mosaicbase_tagging ' if args.enable_mosaicbase_tagging else ""
        cmdline += '--enable_post_filtering ' if args.enable_post_filtering else ""
        args.cmdline = cmdline
    except:
        return args
    logging("[COMMAND] " + cmdline + '\n')
    return args


def print_command_line_to(args):
    try:
        cmdline = os.path.realpath(__file__)
        cmdline += ' --bam_fn {} '.format(args.bam_fn)
        cmdline += '--ref_fn {} '.format(args.ref_fn)
        cmdline += '--threads {} '.format(args.threads)
        cmdline += '--platform {} '.format(args.platform)
        cmdline += '--output_dir {} '.format(args.output_dir)
        cmdline += '--snv_output_prefix {} '.format(args.snv_output_prefix) if args.snv_output_prefix != "snv" else ""
        cmdline += '--indel_output_prefix {} '.format(
            args.indel_output_prefix) if args.indel_output_prefix != "indel" else ""
        cmdline += '--sample_name {} '.format(args.sample_name) if args.sample_name != "SAMPLE" else ""
        cmdline += '--ctg_name {} '.format(args.ctg_name) if args.ctg_name is not None else ""
        cmdline += '--include_all_ctgs ' if args.include_all_ctgs else ""
        cmdline += '--region {} '.format(args.region) if args.region is not None else ""
        cmdline += '--bed_fn {} '.format(args.bed_fn) if args.bed_fn is not None else ""
        cmdline += '--genotyping_mode_vcf_fn {} '.format(
            args.genotyping_mode_vcf_fn) if args.genotyping_mode_vcf_fn is not None else ""
        cmdline += '--hybrid_mode_vcf_fn {} '.format(
            args.hybrid_mode_vcf_fn) if args.hybrid_mode_vcf_fn is not None else ""
        cmdline += '--qual {} '.format(args.qual) if args.qual is not None else ""
        cmdline += '--snv_min_af {} '.format(args.snv_min_af) if args.snv_min_af is not None else ""
        cmdline += '--indel_min_af {} '.format(args.indel_min_af) if args.indel_min_af is not None else ""
        cmdline += '--min_coverage {} '.format(args.min_coverage) if args.min_coverage is not None else ""
        cmdline += '--min_bq {} '.format(args.min_bq) if args.min_bq is not None else ""
        cmdline += '--max_depth {} '.format(args.bam_mplp_set_maxcnt) if args.bam_mplp_set_maxcnt is not None else ""
        cmdline += '--max_indel_depth {} '.format(args.max_indel_length) if args.max_indel_length is not None else ""
        cmdline += '--chunk_size {} '.format(args.chunk_size) if args.chunk_size is not None else ""
        cmdline += '--dry_run ' if args.dry_run else ""
        cmdline += '--remove_intermediate_dir ' if args.remove_intermediate_dir else ""
        cmdline += '--panel_of_normals {} '.format(args.panel_of_normals) if args.panel_of_normals is not None else ""
        cmdline += '--panel_of_normals_require_allele_matching {} '.format(args.panel_of_normals_require_allele_matching) if args.panel_of_normals_require_allele_matching is not None else ""
        cmdline += '--snv_pileup_affirmative_model_path {} '.format(
            args.snv_pileup_affirmative_model_path) if args.snv_pileup_affirmative_model_path is not None else ""
        cmdline += '--indel_pileup_affirmative_model_path {} '.format(
            args.indel_pileup_affirmative_model_path) if args.indel_pileup_affirmative_model_path is not None else ""
        cmdline += '--python {} '.format(args.python) if args.python != "python3" else ""
        cmdline += '--pypy {} '.format(args.pypy) if args.pypy != "pypy3" else ""
        cmdline += '--samtools {} '.format(args.samtools) if args.samtools != "samtools" else ""
        cmdline += '--parallel {} '.format(args.parallel) if args.parallel != "parallel" else ""
        cmdline += '--longphase {} '.format(args.longphase) if args.longphase is not None else ""
        cmdline += '--whatshap {} '.format(args.whatshap) if args.whatshap is not None else ""
        cmdline += '--use_longphase_for_intermediate_phasing {} '.format(
            args.use_longphase_for_intermediate_phasing) if args.use_longphase_for_intermediate_phasing is not None else ""
        cmdline += '--use_whatshap_for_intermediate_phasing {} '.format(
            args.use_whatshap_for_intermediate_phasing) if args.use_whatshap_for_intermediate_phasing is not None else ""
        cmdline += '--use_longphase_for_intermediate_haplotagging {} '.format(
            args.use_longphase_for_intermediate_haplotagging) if args.use_longphase_for_intermediate_haplotagging is not None else ""
        cmdline += '--use_gpu ' if args.use_gpu else ""
        cmdline += '--skip_steps {} '.format(args.skip_steps) if args.skip_steps is not None else ""
        cmdline += '--conda_prefix {} '.format(args.conda_prefix) if args.conda_prefix is not None else ""
        cmdline += '--disable_intermediate_phasing ' if args.disable_intermediate_phasing else ""
        cmdline += '--enable_indel_calling ' if args.enable_indel_calling else ""
        cmdline += '--print_ref_calls ' if args.print_ref_calls else ""
        cmdline += '--disable_nonmosaic_tagging ' if args.disable_nonmosaic_tagging else ""
        cmdline += '--enable_baymgd_tagging ' if args.enable_baymgd_tagging else ""
        cmdline += '--enable_mosaicbase_tagging ' if args.enable_mosaicbase_tagging else ""
        cmdline += '--enable_post_filtering ' if args.enable_post_filtering else ""
        args.cmdline = cmdline
    except:
        return args
    args.cmdline = cmdline
    logging("[COMMAND] " + cmdline + '\n')
    return args


def mosaic_calling_tn(args):
    step = 1
    echo_list = []
    commands_list = []
    clair3_output_path = args.output_dir + '/tmp/clair3_output'

    file_directory = os.path.dirname(os.path.realpath(__file__))
    main_entry = os.path.join(file_directory, "clair_mosaic_tn.py")

    try:
        rc = subprocess.check_call('time', shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        time = 'time '
    except subprocess.CalledProcessError as e:
        time = ''

    if args.clair3_path is not None and args.platform != 'ilmn' and args.phase_input:
        if args.normal_vcf_fn:
            normal_vcf_fn = args.normal_vcf_fn
        else:
            normal_vcf_fn = clair3_output_path + '/clair3_normal_output/merge_output.vcf.gz'
            echo_list.append("[INFO] Call Germline Variants in Control BAM using Clair3")
            clair3_normal_command = '( ' + time + args.clair3_path + '/run_clair3.sh'
            clair3_normal_command += ' --bam_fn ' + args.control_bam_fn
            clair3_normal_command += ' --ref_fn ' + args.ref_fn
            clair3_normal_command += ' --model_path ' + args.clair3_model_path
            clair3_normal_command += ' --platform ' + args.platform
            clair3_normal_command += ' --threads ' + str(args.threads)
            clair3_normal_command += ' --output ' + clair3_output_path + '/clair3_normal_output'
            clair3_normal_command += ' --ctg_name=' + args.clair3_option.ctg_name_str
            clair3_normal_command += ' --samtools=' + args.samtools
            clair3_normal_command += ' --pypy=' + args.pypy
            clair3_normal_command += ' --python=' + args.python
            clair3_normal_command += ' --min_coverage=' + args.clair3_option.min_coverage
            clair3_normal_command += ' --snp_min_af=' + args.clair3_option.snp_min_af
            clair3_normal_command += ' --indel_min_af=' + args.clair3_option.indel_min_af
            if args.clair3_option.longphase_for_phasing is True:
                clair3_normal_command += ' --longphase_for_phasing '
            clair3_normal_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/clair3_log/1_CLAIR3_CONTROL.log'
            commands_list.append(clair3_normal_command)

        echo_list.append("[INFO] Call Germline Variants in Input BAM using Clair3")
        clair3_tumor_command = '( ' + time + args.clair3_path + '/run_clair3.sh'
        clair3_tumor_command += ' --bam_fn ' + args.bam_fn
        clair3_tumor_command += ' --ref_fn ' + args.ref_fn
        clair3_tumor_command += ' --model_path ' + args.clair3_model_path
        clair3_tumor_command += ' --platform ' + args.platform
        clair3_tumor_command += ' --threads ' + str(args.threads)
        clair3_tumor_command += ' --output ' + clair3_output_path + '/clair3_tumor_output'
        clair3_tumor_command += ' --ctg_name=' + args.clair3_option.ctg_name_str
        clair3_tumor_command += ' --samtools=' + args.samtools
        clair3_tumor_command += ' --pypy=' + args.pypy
        clair3_tumor_command += ' --python=' + args.python
        clair3_tumor_command += ' --min_coverage=' + args.clair3_option.min_coverage
        clair3_tumor_command += ' --snp_min_af=' + args.clair3_option.snp_min_af
        clair3_tumor_command += ' --indel_min_af=' + args.clair3_option.indel_min_af
        if args.clair3_option.longphase_for_phasing is True:
            clair3_tumor_command += ' --longphase_for_phasing '
        clair3_tumor_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/clair3_log/2_CLAIR3_INPUT.log'
        commands_list.append(clair3_tumor_command)

        echo_list.append("[INFO] Select Heterozygous SNP for Phasing")
        ssp_command = '( ' + time + args.parallel
        ssp_command += ' --joblog ' + args.output_dir + '/logs/clair3_log/parallel_1_select_hetero_snp_for_phasing.log'
        ssp_command += ' -j ' + str(args.threads)
        ssp_command += ' ' + args.pypy + ' ' + main_entry + ' select_hetero_snp_for_phasing'
        ssp_command += ' --tumor_vcf_fn ' + clair3_output_path + '/clair3_tumor_output/merge_output.vcf.gz'
        ssp_command += ' --normal_vcf_fn ' + normal_vcf_fn
        ssp_command += ' --output_folder ' + clair3_output_path + '/vcf'
        ssp_command += ' --ctg_name {1}'
        ssp_command += ' --use_heterozygous_snp_in_normal_sample_for_intermediate_phasing True' if args.use_heterozygous_snp_in_normal_sample_for_intermediate_phasing else ""
        ssp_command += ' --use_heterozygous_snp_in_tumor_sample_for_intermediate_phasing True' if args.use_heterozygous_snp_in_tumor_sample_for_intermediate_phasing else ""
        ssp_command += ' --use_heterozygous_indel_for_intermediate_phasing True' if args.use_heterozygous_indel_for_intermediate_phasing else ""
        ssp_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
        ssp_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/clair3_log/1_select_hetero_snp_for_phasing.log'
        commands_list.append(ssp_command)

        if args.phase_control:
            echo_list.append("[INFO] Phase the Control BAM")
            if args.clair3_option.longphase_for_phasing is not None:
                pn_command = '( ' + time + args.parallel
                pn_command += ' --joblog ' + args.output_dir + '/logs/clair3_log/parallel_2_phase_control.log'
                pn_command += ' -j ' + str(args.threads)
                pn_command += ' ' + args.longphase + ' phase '
                pn_command += ' -s ' + clair3_output_path + '/vcf/{1}.vcf'
                pn_command += ' -b ' + args.control_bam_fn
                pn_command += ' -r ' + args.ref_fn
                pn_command += ' -t ' + str(args.threads)
                pn_command += ' --indels ' if args.use_heterozygous_indel_for_intermediate_phasing else ""
                pn_command += ' -o ' + clair3_output_path + '/phased_output/control_phased_{1}'
                pn_command += ' --ont' if args.platform == 'ont' else ' --pb'
                pn_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
                pn_command += ' && ' + args.parallel
                pn_command += ' -j ' + str(args.threads)
                pn_command += ' bgzip -f ' + clair3_output_path + '/phased_output/control_phased_{1}.vcf'
                pn_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
                pn_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/clair3_log/2_phase_control.log'
            else:
                pn_command = '( ' + time + args.parallel
                pn_command += ' --joblog ' + args.output_dir + '/logs/clair3_log/parallel_2_phase_control.log'
                pn_command += ' -j ' + str(args.threads)
                pn_command += ' ' + args.whatshap + ' phase '
                pn_command += ' --output ' + clair3_output_path + '/phased_output/control_phased_{1}.vcf.gz'
                pn_command += ' --reference ' + args.ref_fn
                pn_command += ' --chromosome {1}'
                pn_command += ' --distrust-genotypes'
                pn_command += ' --ignore-read-groups'
                pn_command += ' ' + clair3_output_path + '/vcf/{1}.vcf'
                pn_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
                pn_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/clair3_log/2_phase_control.log'

            tabix_command = args.parallel + ' -j ' + str(args.threads)
            tabix_command += ' tabix' + ' -f -p vcf'
            tabix_command += ' ' + clair3_output_path + '/phased_output/control_phased_{1}.vcf.gz'
            tabix_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
            commands_list.append(pn_command + ' && ' + tabix_command)

            echo_list.append("[INFO] Haplotag the Control BAM")
            ht_command = '( ' + time + args.parallel
            ht_command += ' --joblog ' + args.output_dir + '/logs/parallel_3_haplotag_control.log'
            ht_command += ' -j ' + str(args.threads)
            ht_command += ' ' + args.whatshap + ' haplotag'
            ht_command += ' --output ' + clair3_output_path + '/phased_output/control_{1}.bam'
            ht_command += ' --reference ' + args.ref_fn
            ht_command += ' --regions {1} '
            ht_command += ' --ignore-read-groups'
            ht_command += ' ' + clair3_output_path + '/phased_output/control_phased_{1}.vcf.gz'
            ht_command += ' ' + args.control_bam_fn
            ht_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
            ht_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/3_control_haplotag.log'

            index_command = args.parallel + ' -j ' + str(args.threads)
            index_command += ' ' + args.samtools + ' index '
            index_command += ' -@' + str(args.threads)
            index_command += ' ' + clair3_output_path + '/phased_output/control_{1}.bam'
            index_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
            commands_list.append(ht_command + ' && ' + index_command)

        echo_list.append("[INFO] Phase the Input BAM")
        if args.clair3_option.longphase_for_phasing is not None:
            pt_command = '( ' + time + args.parallel
            pt_command += ' --joblog ' + args.output_dir + '/logs/clair3_log/parallel_4_phase_input.log'
            pt_command += ' -j ' + str(args.threads)
            pt_command += ' ' + args.clair3_option.longphase + ' phase '
            pt_command += ' -s ' + clair3_output_path + '/vcf/{1}.vcf'
            pt_command += ' -b ' + (args.bam_fn if not args.use_normal_bam_for_intermediate_phasing else args.control_bam_fn)
            pt_command += ' -r ' + args.ref_fn
            pt_command += ' -t ' + str(args.threads)
            pt_command += ' --indels ' if args.use_heterozygous_indel_for_intermediate_phasing else ""
            pt_command += ' -o ' + clair3_output_path + '/phased_output/input_phased_{1}'
            pt_command += ' --ont' if args.platform == 'ont' else ' --pb'
            pt_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
            pt_command += ' && ' + args.parallel
            pt_command += ' -j ' + str(args.threads)
            pt_command += ' bgzip -f ' + clair3_output_path + '/phased_output/input_phased_{1}.vcf'
            pt_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
            pt_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/clair3_log/4_phase_input.log'
        else:
            pt_command = '( ' + time + args.parallel
            pt_command += ' --joblog ' + args.output_dir + '/logs/clair3_log/parallel_4_phase_input.log'
            pt_command += ' -j ' + str(args.threads)
            pt_command += ' ' + args.whatshap + ' phase '
            pt_command += ' --output ' + clair3_output_path + '/phased_output/input_phased_{1}.vcf.gz'
            pt_command += ' --reference ' + args.ref_fn
            pt_command += ' --chromosome {1}'
            pt_command += ' --distrust-genotypes'
            pt_command += ' --ignore-read-groups'
            pt_command += ' ' + clair3_output_path + '/vcf/{1}.vcf'
            pt_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
            pt_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/clair3_log/4_phase_input.log'

        tabix_command = args.parallel + ' -j ' + str(args.threads)
        tabix_command += ' tabix' + ' -f -p vcf'
        tabix_command += ' ' + clair3_output_path + '/phased_output/input_phased_{1}.vcf.gz'
        tabix_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
        commands_list.append(pt_command + ' && ' + tabix_command)

        echo_list.append("[INFO] Haplotag the Input BAM")
        if args.use_longphase_for_intermediate_haplotagging:
            ht_command = '( ' + time + args.parallel
            ht_command += ' --joblog ' + args.output_dir + '/logs/clair3_log/parallel_5_haplotag_input.log'
            ht_command += ' -j ' + str(args.threads)
            ht_command += ' ' + args.longphase + ' haplotag'
            ht_command += ' -o ' + clair3_output_path + '/phased_output/input_{1}'
            ht_command += ' --reference ' + args.ref_fn
            ht_command += ' --region {1} '
            ht_command += ' -s ' + clair3_output_path + '/phased_output/input_phased_{1}.vcf.gz'
            ht_command += ' -b ' + args.bam_fn
            ht_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
            ht_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/clair3_log/5_input_haplotag.log'
        else:
            ht_command = '( ' + time + args.parallel
            ht_command += ' --joblog ' + args.output_dir + '/logs/clair3_log/parallel_5_haplotag_input.log'
            ht_command += ' -j ' + str(args.threads)
            ht_command += ' ' + args.whatshap + ' haplotag'
            ht_command += ' --output ' + clair3_output_path + '/phased_output/input_{1}.bam'
            ht_command += ' --reference ' + args.ref_fn
            ht_command += ' --regions {1} '
            ht_command += ' --ignore-read-groups'
            ht_command += ' ' + clair3_output_path + '/phased_output/input_phased_{1}.vcf.gz'
            ht_command += ' ' + args.bam_fn
            ht_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
            ht_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/clair3_log/5_input_haplotag.log'

        index_command = args.parallel + ' -j ' + str(args.threads)
        index_command += ' ' + args.samtools + ' index '
        index_command += ' -@' + str(args.threads)
        index_command += ' ' + clair3_output_path + '/phased_output/input_{1}.bam'
        index_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
        commands_list.append(ht_command + ' && ' + index_command)

    # Pileup calling
    #STEP 1: EXTRACT CANDIDATES
    echo_list.append("[INFO] STEP {}: Extract Variant Candidates from Input and Control BAMs".format(step))
    step += 1
    ec_command = '( ' + time + args.parallel
    ec_command += ' --joblog ' + args.output_dir + '/logs/parallel_1_extract_tumor_candidates.log'
    ec_command += ' -C " " -j ' + str(args.threads)
    ec_command += ' ' + args.pypy + ' ' + main_entry + ' extract_pair_candidates'
    ec_command += ' --tumor_bam_fn ' + args.bam_fn
    ec_command += ' --normal_bam_fn ' + args.control_bam_fn
    ec_command += ' --ref_fn ' + args.ref_fn
    ec_command += ' --samtools ' + args.samtools
    ec_command += ' --snv_min_af ' + str(args.snv_min_af)
    ec_command += ' --indel_min_af ' + str(args.indel_min_af)
    ec_command += ' --chunk_id {2} '
    ec_command += ' --chunk_num {3} '
    ec_command += ' --ctg_name {1} '
    ec_command += ' --platform ' + args.platform
    ec_command += ' --min_coverage ' + str(args.min_coverage)
    ec_command += (' --min_bq ' + str(args.min_bq)) if args.min_bq is not None else ""
    ec_command += ' --bed_fn ' + os.path.join(args.output_dir, 'tmp', 'split_beds', '{1}')
    ec_command += ' --candidates_folder ' + args.output_dir + '/tmp/candidates'
    ec_command += ' --output_depth True '
    ec_command += ' --select_indel_candidates ' + str(args.enable_indel_calling)
    ec_command += ' --hybrid_mode_vcf_fn ' + str(args.hybrid_mode_vcf_fn)
    ec_command += ' --genotyping_mode_vcf_fn ' + str(args.genotyping_mode_vcf_fn)
    ec_command += ' :::: ' + os.path.join(args.output_dir, 'tmp', 'CHUNK_LIST')
    ec_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/1_EC.log'
    ec_command += ' && ' + args.pypy + ' ' + main_entry + ' concat_files'
    ec_command += ' --input_dir ' + "{}/tmp/candidates".format(args.output_dir)
    ec_command += ' --input_prefix ' + "CANDIDATES_FILE_"
    ec_command += ' --output_fn CANDIDATES_FILES '
    commands_list.append(ec_command)

    ##STEP 2: CREATE PAIR TENSOR
    echo_list.append("[INFO] STEP 2: Pileup Model Calling\n")
    echo_list[-1] += ("[INFO] Create Paired Tensors")
    cpt_command = '( ' + time + args.parallel
    cpt_command += ' --joblog ' + args.output_dir + '/logs/parallel_2-1_create_pair_tensor.log'
    cpt_command += ' -j ' + str(args.threads)
    cpt_command += ' ' + args.pypy + ' ' + main_entry + ' create_pair_tensor_pileup'
    cpt_command += ' --normal_bam_fn ' + args.control_bam_fn
    cpt_command += ' --tumor_bam_fn ' + args.bam_fn
    cpt_command += ' --ref_fn ' + args.ref_fn
    cpt_command += ' --ctg_name {1/.}'
    cpt_command += (' --min_bq ' + str(args.min_bq)) if args.min_bq is not None else ""
    cpt_command += ' --samtools ' + args.samtools
    cpt_command += ' --candidates_bed_regions {1}'
    cpt_command += ' --tensor_can_fn ' + args.output_dir + '/tmp/pileup_tensor_can/{1/} '
    cpt_command += ' --platform ' + args.platform
    cpt_command += ' :::: ' + args.output_dir + '/tmp/candidates/CANDIDATES_FILES'
    cpt_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/2-1_CPT.log'
    commands_list += [cpt_command]

    ## STEP 3: PREDICT
    echo_list.append("[INFO] Pileup Model Prediction")
    p_predict_command = '( ' + time + args.parallel
    p_predict_command += ' --joblog ' + args.output_dir + '/logs/parallel_2-2_predict.log'
    p_predict_command += ' -j ' + str(args.threads)
    p_predict_command += ' ' + args.python + ' ' + main_entry + ' predict'
    p_predict_command += ' --tensor_fn ' + args.output_dir + '/tmp/pileup_tensor_can/{1/} '
    p_predict_command += ' --call_fn ' + args.output_dir + '/tmp/vcf_output/p_{1/}.vcf'
    p_predict_command += ' --chkpnt_fn ' + args.pileup_model_path
    p_predict_command += ' --use_gpu ' + str(args.use_gpu)
    p_predict_command += ' --platform ' + args.platform
    p_predict_command += ' --ctg_name {1/.}'
    p_predict_command += ' --pileup '
    p_predict_command += ' --show_ref ' if args.print_ref_calls else ""
    p_predict_command += ' --show_germline ' if args.print_germline_calls else ""
    p_predict_command += ' :::: ' + args.output_dir + '/tmp/candidates/CANDIDATES_FILES'
    p_predict_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/2-2_PREDICT.log'
    commands_list += [p_predict_command]

    # STEP 4: MERGE VCF
    echo_list.append("[INFO] Merge Pileup VCFs")
    p_mv_command = args.pypy + ' ' + main_entry + ' sort_vcf'
    p_mv_command += ' --ref_fn ' + args.ref_fn
    p_mv_command += ' --contigs_fn ' + os.path.join(args.output_dir, 'tmp', 'CONTIGS')
    p_mv_command += ' --input_dir ' + args.output_dir + '/tmp/vcf_output'
    p_mv_command += ' --vcf_fn_prefix ' + 'p_'
    p_mv_command += ' --output_fn ' + args.output_dir + '/tmp/vcf_output/snv_pileup.vcf'
    commands_list += [p_mv_command]

    if not args.disable_nonmosaic_tagging:
        # SNV NON-MOSAIC TAGGING
        echo_list.append("[INFO] Non-mosaic Tagging for SNV Variants")
        gf_command = '( ' + time + args.parallel
        gf_command += ' --joblog ' + args.output_dir + '/logs/parallel_nonmosaic_tagging_snv.log'
        gf_command += ' -j ' + str(args.threads)
        gf_command += ' ' + args.pypy + ' ' + main_entry + ' nonsomatic_tagging'
        gf_command += ' --pileup_vcf_fn ' + args.output_dir + '/tmp/vcf_output/snv_pileup.vcf'
        gf_command += ' --output_vcf_fn ' + args.output_dir + '/tmp/vcf_output/snv_nonmosaic_tagging_{1}.vcf'
        gf_command += ' --ctg_name {1} '
        gf_command += ' --pypy3 ' + args.pypy
        gf_command += ' --parallel ' + args.parallel
        gf_command += ' --show_ref ' if args.print_ref_calls else ''
        gf_command += ' --disable_print_nonmosaic_calls ' if args.disable_print_nonmosaic_calls else ''
        gf_command += ' --panel_of_normals {} '.format(
            args.panel_of_normals) if args.panel_of_normals is not None else ''
        gf_command += ' --panel_of_normals_require_allele_matching {} '.format(
            args.panel_of_normals_require_allele_matching) if args.panel_of_normals_require_allele_matching is not None else ''
        gf_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
        gf_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/NONMOSAIC_TAG_SNV.log'
        commands_list += [gf_command]

        # MERGE SNV NON-MOSAIC TAGGING VCFs
        echo_list.append("[INFO] Merge SNV Non-mosaic Tagging VCFs")
        p_mv_command = args.pypy + ' ' + main_entry + ' sort_vcf'
        p_mv_command += ' --ref_fn ' + args.ref_fn
        p_mv_command += ' --contigs_fn ' + os.path.join(args.output_dir, 'tmp', 'CONTIGS')
        p_mv_command += ' --input_dir ' + args.output_dir + '/tmp/vcf_output'
        p_mv_command += ' --vcf_fn_prefix ' + 'snv_nonmosaic_tagging_'
        p_mv_command += ' --output_fn ' + args.output_dir + '/tmp/vcf_output/snv_pileup_nonmosaic_tagging.vcf'
        commands_list += [p_mv_command]
    else:
        # SNV NON-MOSAIC TAGGING
        echo_list.append("[INFO] Non-mosaic Tagging for SNV Variants")
        nst_command = "ln -sf {} {}".format(args.output_dir + '/tmp/vcf_output/snv_pileup.vcf',
                                            args.output_dir + '/tmp/vcf_output/snv_pileup_nonmosaic_tagging.vcf')
        commands_list += [nst_command]

    if args.enable_baymgd_tagging:
        # SNV BAYMGD TAGGING
        echo_list.append("[INFO] BayMGD Tagging for SNV Variants")
        bt_command = '( ' + time + args.parallel
        bt_command += ' --joblog ' + args.output_dir + '/logs/parallel_baymgd_tagging_snv.log'
        bt_command += ' -j ' + str(args.threads)
        bt_command += ' ' + args.python + ' ' + main_entry + ' baymgd_tagging'
        bt_command += ' --pileup_vcf_fn ' + args.output_dir + '/tmp/vcf_output/snv_pileup_nonmosaic_tagging.vcf'
        bt_command += ' --output_vcf_fn ' + args.output_dir + '/tmp/vcf_output/snv_pileup_baymgd_tagging_{1}.vcf'
        bt_command += ' --ctg_name {1} '
        bt_command += ' --pypy3 ' + args.pypy
        bt_command += ' --parallel ' + args.parallel
        bt_command += ' --show_ref ' if args.print_ref_calls else ''
        bt_command += ' --show_germline ' if args.print_germline_calls else ''
        bt_command += ' --disable_print_nonmosaic_calls ' if args.disable_print_nonmosaic_calls else ''
        bt_command += ' --gnomad_dir {} '.format(args.gnomad_dir) if args.gnomad_dir is not None else ''
        bt_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
        bt_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/BAYMGD_TAG_SNV.log'
        commands_list += [bt_command]

        # MERGE SNV BAYMGD TAGGING VCFs
        echo_list.append("[INFO] Merge SNV BayMGD Tagging VCFs")
        p_mv_command = args.pypy + ' ' + main_entry + ' sort_vcf'
        p_mv_command += ' --ref_fn ' + args.ref_fn
        p_mv_command += ' --contigs_fn ' + os.path.join(args.output_dir, 'tmp', 'CONTIGS')
        p_mv_command += ' --input_dir ' + args.output_dir + '/tmp/vcf_output'
        p_mv_command += ' --vcf_fn_prefix ' + 'snv_pileup_baymgd_tagging_'
        p_mv_command += ' --output_fn ' + args.output_dir + '/tmp/vcf_output/snv_pileup_baymgd_tagging.vcf'
        commands_list += [p_mv_command]
    else:
        # SNV BAYMGD TAGGING
        echo_list.append("[INFO] BayMGD Tagging for SNV Variants")
        bt_command = "ln -sf {} {}".format(args.output_dir + '/tmp/vcf_output/snv_pileup_nonmosaic_tagging.vcf',
                                            args.output_dir + '/tmp/vcf_output/snv_pileup_baymgd_tagging.vcf')
        commands_list += [bt_command]

    if args.enable_mosaicbase_tagging:
        # SNV MOSAICBASE TAGGING
        echo_list.append("[INFO] MosaicBase Tagging for SNV Variants")
        mt_command = '( ' + time + args.parallel
        mt_command += ' --joblog ' + args.output_dir + '/logs/parallel_mosaicbase_tagging_snv.log'
        mt_command += ' -j ' + str(args.threads)
        mt_command += ' ' + args.pypy + ' ' + main_entry + ' mosaicbase_tagging'
        mt_command += ' --pileup_vcf_fn ' + args.output_dir + '/tmp/vcf_output/snv_pileup_baymgd_tagging.vcf'
        mt_command += ' --output_vcf_fn ' + args.output_dir + '/tmp/vcf_output/snv_pileup_mosaicbase_tagging_{1}.vcf'
        mt_command += ' --ctg_name {1} '
        mt_command += ' --pypy3 ' + args.pypy
        mt_command += ' --parallel ' + args.parallel
        mt_command += ' --show_ref ' if args.print_ref_calls else ''
        mt_command += ' --show_germline ' if args.print_germline_calls else ''
        mt_command += ' --disable_print_nonmosaic_calls ' if args.disable_print_nonmosaic_calls else ''
        mt_command += ' --mosaicbase_fn {} '.format(args.mosaicbase_fn) if args.mosaicbase_fn is not None else ''
        mt_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
        mt_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/MOSAICBASE_TAG_SNV.log'
        commands_list += [mt_command]

        # MERGE SNV MOSAICBASE TAGGING VCFs
        echo_list.append("[INFO] Merge SNV MosaicBase Tagging VCFs")
        p_mv_command = args.pypy + ' ' + main_entry + ' sort_vcf'
        p_mv_command += ' --ref_fn ' + args.ref_fn
        p_mv_command += ' --contigs_fn ' + os.path.join(args.output_dir, 'tmp', 'CONTIGS')
        p_mv_command += ' --input_dir ' + args.output_dir + '/tmp/vcf_output'
        p_mv_command += ' --vcf_fn_prefix ' + 'snv_pileup_mosaicbase_tagging_'
        p_mv_command += ' --output_fn ' + args.output_dir + '/tmp/vcf_output/snv_pileup_mosaicbase_tagging.vcf'
        commands_list += [p_mv_command]
    else:
        # SNV MOSAICBASE TAGGING
        echo_list.append("[INFO] MosaicBase Tagging for SNV Variants")
        mt_command = "ln -sf {} {}".format(args.output_dir + '/tmp/vcf_output/snv_pileup_baymgd_tagging.vcf',
                                            args.output_dir + '/tmp/vcf_output/snv_pileup_mosaicbase_tagging.vcf')
        commands_list += [mt_command]

    input_bam_prefix = clair3_output_path + '/phased_output/input_' if args.phase_input else args.bam_fn

    if args.enable_post_filtering and args.platform != 'ilmn':
        # POST FILTERING for SNV Variants
        echo_list.append("[INFO] Post Filtering for SNV Variants")
        hap_g_command = '( ' + time + args.pypy + ' ' + main_entry + ' haplotype_filtering'
        hap_g_command += ' --tumor_bam_fn ' + input_bam_prefix
        hap_g_command += ' --ref_fn ' + args.ref_fn
        hap_g_command += ' --germline_vcf_fn ' + clair3_output_path + '/clair3_tumor_output/merge_output.vcf.gz'
        hap_g_command += ' --pileup_vcf_fn ' + args.output_dir + '/tmp/vcf_output/snv_pileup_mosaicbase_tagging.vcf'
        hap_g_command += ' --output_dir ' + args.output_dir + '/tmp/vcf_output'
        hap_g_command += ' --cmrg_bed_fn {}'.format(args.cmrg_bed_fn) if args.cmrg_bed_fn is not None else ''
        hap_g_command += ' --samtools ' + args.samtools
        hap_g_command += ' --pypy3 ' + args.pypy
        hap_g_command += ' --parallel ' + args.parallel
        hap_g_command += ' --threads ' + str(args.threads)
        hap_g_command += ' --debug ' if args.debug else ''
        hap_g_command += ' --show_ref ' if args.print_ref_calls else ''
        hap_g_command += ' --apply_post_processing False' if not args.enable_post_filtering else ''
        hap_g_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/POSTFILTER_SNV.log'
        commands_list += [hap_g_command]
    else:
        # POST FILTERING for SNV Variants
        echo_list.append("[INFO] Post Filtering for SNV Variants")
        pf_command = "ln -sf {} {}".format(args.output_dir + '/tmp/vcf_output/snv_pileup_mosaicbase_tagging.vcf',
                                            args.output_dir + '/tmp/vcf_output/snv_pileup_filtering.vcf')
        commands_list += [pf_command]

    echo_list.append("[INFO] STEP 3: Merge and sort VCF")
    sort_vcf_command = '( ' + time + args.pypy + ' ' + main_entry + ' merge_vcf'
    sort_vcf_command += ' --ref_fn ' + args.ref_fn
    sort_vcf_command += ' --pileup_vcf_fn ' + args.output_dir + '/tmp/vcf_output/snv_pileup_filtering.vcf'
    sort_vcf_command += ' --output_fn ' + args.output_dir + '/{}.vcf'.format(args.output_prefix)
    sort_vcf_command += ' --platform ' + args.platform
    sort_vcf_command += ' --qual ' + str(args.qual)
    sort_vcf_command += ' --sample_name ' + str(args.sample_name)
    sort_vcf_command += ' --enable_indel_calling ' + str(args.enable_indel_calling)
    sort_vcf_command += ' --prefer_recall ' + str(args.prefer_recall)
    sort_vcf_command += ' --cmdline ' + args.output_dir + '/tmp/CMD'
    sort_vcf_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/3_MV.log'
    commands_list += [sort_vcf_command]

    if args.genotyping_mode_vcf_fn is not None or args.hybrid_mode_vcf_fn is not None:
        echo_list.append("[INFO] Add reference calls to the output VCF output")
        genotyping_command = args.pypy + ' ' + main_entry + ' add_back_missing_variants_in_genotyping'
        genotyping_command += ' --genotyping_mode_vcf_fn ' + str(args.genotyping_mode_vcf_fn)
        genotyping_command += ' --hybrid_mode_vcf_fn ' + str(args.hybrid_mode_vcf_fn)
        genotyping_command += ' --call_fn ' + args.output_dir + '/{}.vcf.gz'.format(args.output_prefix)
        genotyping_command += ' --output_fn ' + args.output_dir + '/{}.vcf'.format(args.output_prefix)
        genotyping_command += ' --candidates_folder ' + args.output_dir + '/tmp/candidates'
        genotyping_command += ' 2>&1 | tee ' + args.output_dir + '/logs/4_GT.log'
        commands_list += [genotyping_command]

    if args.enable_indel_calling:
        ##STEP 2: CREATE PAIR TENSOR
        echo_list.append("[INFO] STEP 4: Indel Pileup Model Calling\n")
        echo_list[-1] += ("[INFO] Create Paired Tensors")
        indel_cpt_command = args.pypy + ' ' + main_entry + ' concat_files'
        indel_cpt_command += ' --input_dir ' + "{}/tmp/candidates".format(args.output_dir)
        indel_cpt_command += ' --input_prefix ' + "INDEL_CANDIDATES_FILE_"
        indel_cpt_command += ' --output_fn INDEL_CANDIDATES_FILES '
        indel_cpt_command += ' && ( ' + time + args.parallel
        indel_cpt_command += ' --joblog ' + args.output_dir + '/logs/parallel_4-1_create_pair_tensor_indel.log'
        indel_cpt_command += ' -j ' + str(args.threads)
        indel_cpt_command += ' ' + args.pypy + ' ' + main_entry + ' create_pair_tensor_pileup'
        indel_cpt_command += ' --normal_bam_fn ' + args.control_bam_fn
        indel_cpt_command += ' --tumor_bam_fn ' + args.bam_fn
        indel_cpt_command += ' --ref_fn ' + args.ref_fn
        indel_cpt_command += ' --ctg_name {1/.}'
        indel_cpt_command += ' --samtools ' + args.samtools
        indel_cpt_command += ' --candidates_bed_regions {1}'
        indel_cpt_command += ' --tensor_can_fn ' + args.output_dir + '/tmp/pileup_tensor_can/indel_{1/} '
        indel_cpt_command += ' --platform ' + args.platform
        indel_cpt_command += ' :::: ' + args.output_dir + '/tmp/candidates/INDEL_CANDIDATES_FILES'
        indel_cpt_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/4-1_CPTI.log'
        commands_list += [indel_cpt_command]

        ## INDEL PREDICT
        echo_list.append("[INFO] Indel Pileup Model Prediction")
        indel_p_predict_command = '( ' + time + args.parallel
        indel_p_predict_command += ' --joblog ' + args.output_dir + '/logs/parallel_4-2_predict_indel.log'
        indel_p_predict_command += ' -j ' + str(args.threads)
        indel_p_predict_command += ' ' + args.python + ' ' + main_entry + ' predict'
        indel_p_predict_command += ' --tensor_fn ' + args.output_dir + '/tmp/pileup_tensor_can/indel_{1/} '
        indel_p_predict_command += ' --call_fn ' + args.output_dir + '/tmp/vcf_output/indel_p_{1/}.vcf'
        indel_p_predict_command += ' --chkpnt_fn ' + args.indel_pileup_model_path
        indel_p_predict_command += ' --use_gpu ' + str(args.use_gpu)
        indel_p_predict_command += ' --platform ' + args.platform
        indel_p_predict_command += ' --ctg_name {1/.}'
        indel_p_predict_command += ' --pileup '
        indel_p_predict_command += ' --enable_indel_calling True '
        indel_p_predict_command += ' --show_ref ' if args.print_ref_calls else ""
        indel_p_predict_command += ' --show_germline ' if args.print_germline_calls else ""
        indel_p_predict_command += ' :::: ' + args.output_dir + '/tmp/candidates/INDEL_CANDIDATES_FILES'
        indel_p_predict_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/4-2_PREDICT_INDEL.log'
        commands_list += [indel_p_predict_command]

        # MERGE INDEL VCF
        echo_list.append("[INFO] Merge Pileup VCFs")
        indel_p_mv_command = args.pypy + ' ' + main_entry + ' sort_vcf'
        indel_p_mv_command += ' --ref_fn ' + args.ref_fn
        indel_p_mv_command += ' --contigs_fn ' + os.path.join(args.output_dir, 'tmp', 'CONTIGS')
        indel_p_mv_command += ' --input_dir ' + args.output_dir + '/tmp/vcf_output'
        indel_p_mv_command += ' --vcf_fn_prefix ' + 'indel_p_'
        indel_p_mv_command += ' --output_fn ' + args.output_dir + '/tmp/vcf_output/indel_pileup.vcf'
        commands_list += [indel_p_mv_command]

        if not args.disable_nonmosaic_tagging:
            # INDEL NON-MOSAIC TAGGING
            echo_list.append("[INFO] Non-mosaic Tagging for Indel Variants")
            indel_gf_command = '( ' + time + args.parallel
            indel_gf_command += ' --joblog ' + args.output_dir + '/logs/parallel_nonmosaic_tagging_indel.log'
            indel_gf_command += ' -j ' + str(args.threads)
            indel_gf_command += ' ' + args.pypy + ' ' + main_entry + ' nonsomatic_tagging'
            indel_gf_command += ' --pileup_vcf_fn ' + args.output_dir + '/tmp/vcf_output/indel_pileup.vcf'
            indel_gf_command += ' --output_vcf_fn ' + args.output_dir + '/tmp/vcf_output/indel_nonmosaic_tagging_{1}.vcf'
            indel_gf_command += ' --ctg_name {1} '
            indel_gf_command += ' --pypy3 ' + args.pypy
            indel_gf_command += ' --parallel ' + args.parallel
            indel_gf_command += ' --show_ref ' if args.print_ref_calls else ''
            indel_gf_command += ' --disable_print_nonmosaic_calls ' if args.disable_print_nonmosaic_calls else ''
            indel_gf_command += ' --panel_of_normals {} '.format(
                args.panel_of_normals) if args.panel_of_normals is not None else ''
            indel_gf_command += ' --panel_of_normals_require_allele_matching {} '.format(
                args.panel_of_normals_require_allele_matching) if args.panel_of_normals_require_allele_matching is not None else ''
            indel_gf_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
            indel_gf_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/NONMOSAIC_TAG_INDEL.log'
            commands_list += [indel_gf_command]

            # MERGE INDEL NON-MOSAIC TAGGING VCFs
            echo_list.append("[INFO] Merge Indel Non-mosaic Tagging VCFs")
            indel_p_mv_command = args.pypy + ' ' + main_entry + ' sort_vcf'
            indel_p_mv_command += ' --ref_fn ' + args.ref_fn
            indel_p_mv_command += ' --contigs_fn ' + os.path.join(args.output_dir, 'tmp', 'CONTIGS')
            indel_p_mv_command += ' --input_dir ' + args.output_dir + '/tmp/vcf_output'
            indel_p_mv_command += ' --vcf_fn_prefix ' + 'indel_nonmosaic_tagging_'
            indel_p_mv_command += ' --output_fn ' + args.output_dir + '/tmp/vcf_output/indel_pileup_nonmosaic_tagging.vcf'
            commands_list += [indel_p_mv_command]
        else:
            # INDEL NON-MOSAIC TAGGING
            echo_list.append("[INFO] Non-mosaic Tagging for SNV Variants")
            indel_nst_command = "ln -sf {} {}".format(args.output_dir + '/tmp/vcf_output/indel_pileup.vcf',
                                                      args.output_dir + '/tmp/vcf_output/indel_pileup_nonmosaic_tagging.vcf')
            commands_list += [indel_nst_command]

        if args.enable_baymgd_tagging:
            # INDEL BAYMGD TAGGING
            echo_list.append("[INFO] BayMGD Tagging for Indel Variants")
            indel_bt_command = '( ' + time + args.parallel
            indel_bt_command += ' --joblog ' + args.output_dir + '/logs/parallel_baymgd_tagging_indel.log'
            indel_bt_command += ' -j ' + str(args.threads)
            indel_bt_command += ' ' + args.python + ' ' + main_entry + ' baymgd_tagging'
            indel_bt_command += ' --pileup_vcf_fn ' + args.output_dir + '/tmp/vcf_output/indel_pileup_nonmosaic_tagging.vcf'
            indel_bt_command += ' --output_vcf_fn ' + args.output_dir + '/tmp/vcf_output/indel_pileup_baymgd_tagging_{1}.vcf'
            indel_bt_command += ' --ctg_name {1} '
            indel_bt_command += ' --pypy3 ' + args.pypy
            indel_bt_command += ' --parallel ' + args.parallel
            indel_bt_command += ' --show_ref ' if args.print_ref_calls else ''
            indel_bt_command += ' --show_germline ' if args.print_germline_calls else ''
            indel_bt_command += ' --disable_print_nonmosaic_calls ' if args.disable_print_nonmosaic_calls else ''
            indel_bt_command += ' --gnomad_dir {} '.format(args.gnomad_dir) if args.gnomad_dir is not None else ''
            indel_bt_command += ' --is_indel '
            indel_bt_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
            indel_bt_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/BAYMGD_TAG_INDEL.log'
            commands_list += [indel_bt_command]

            # MERGE INDEL BAYMGD TAGGING VCFs
            echo_list.append("[INFO] Merge Indel BayMGD Tagging VCFs")
            indel_p_mv_command = args.pypy + ' ' + main_entry + ' sort_vcf'
            indel_p_mv_command += ' --ref_fn ' + args.ref_fn
            indel_p_mv_command += ' --contigs_fn ' + os.path.join(args.output_dir, 'tmp', 'CONTIGS')
            indel_p_mv_command += ' --input_dir ' + args.output_dir + '/tmp/vcf_output'
            indel_p_mv_command += ' --vcf_fn_prefix ' + 'indel_pileup_baymgd_tagging_'
            indel_p_mv_command += ' --output_fn ' + args.output_dir + '/tmp/vcf_output/indel_pileup_baymgd_tagging.vcf'
            commands_list += [indel_p_mv_command]
        else:
            # INDEL BAYMGD TAGGING
            echo_list.append("[INFO] BayMGD Tagging for Indel Variants")
            indel_bt_command = "ln -sf {} {}".format(args.output_dir + '/tmp/vcf_output/indel_pileup_nonmosaic_tagging.vcf',
                                               args.output_dir + '/tmp/vcf_output/indel_pileup_baymgd_tagging.vcf')
            commands_list += [indel_bt_command]

        if args.enable_post_filtering and args.platform != 'ilmn':
            # POST FILTERING for INDEL Variants
            echo_list.append("[INFO] Post Filtering for Indel Variants")
            indel_hap_g_command = '( ' + time + args.pypy + ' ' + main_entry + ' haplotype_filtering'
            indel_hap_g_command += ' --tumor_bam_fn ' + input_bam_prefix
            indel_hap_g_command += ' --ref_fn ' + args.ref_fn
            indel_hap_g_command += ' --germline_vcf_fn ' + clair3_output_path + '/clair3_tumor_output/merge_output.vcf.gz'
            indel_hap_g_command += ' --pileup_vcf_fn ' + args.output_dir + '/tmp/vcf_output/indel_pileup_baymgd_tagging.vcf'
            indel_hap_g_command += ' --output_dir ' + args.output_dir + '/tmp/vcf_output'
            indel_hap_g_command += ' --cmrg_bed_fn {}'.format(args.cmrg_bed_fn) if args.cmrg_bed_fn is not None else ''
            indel_hap_g_command += ' --samtools ' + args.samtools
            indel_hap_g_command += ' --pypy3 ' + args.pypy
            indel_hap_g_command += ' --parallel ' + args.parallel
            indel_hap_g_command += ' --threads ' + str(args.threads)
            indel_hap_g_command += ' --debug ' if args.debug else ''
            indel_hap_g_command += ' --show_ref ' if args.print_ref_calls else ''
            indel_hap_g_command += ' --is_indel '
            indel_hap_g_command += ' --apply_post_processing False' if not args.enable_post_filtering else ''
            indel_hap_g_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/POSTFILTER_INDEL.log'
            commands_list += [indel_hap_g_command]
        else:
            # POST FILTERING for INDEL Variants
            echo_list.append("[INFO] Post Filtering for Indel Variants")
            indel_pf_command = "ln -sf {} {}".format(args.output_dir + '/tmp/vcf_output/indel_pileup_baymgd_tagging.vcf',
                                               args.output_dir + '/tmp/vcf_output/indel_pileup_filtering.vcf')
            commands_list += [indel_pf_command]

        indel_pileup_fn = args.output_dir + '/tmp/vcf_output/indel_pileup_filtering.vcf'

        echo_list.append("[INFO] STEP 5: Merge and sort Indel VCF")
        indel_sort_vcf_command = '( ' + time + args.pypy + ' ' + main_entry + ' merge_vcf'
        indel_sort_vcf_command += ' --ref_fn ' + args.ref_fn
        indel_sort_vcf_command += ' --pileup_vcf_fn ' + indel_pileup_fn
        indel_sort_vcf_command += ' --output_fn ' + args.output_dir + '/{}.vcf'.format(args.indel_output_prefix)
        indel_sort_vcf_command += ' --platform ' + args.platform
        indel_sort_vcf_command += ' --qual ' + str(args.qual)
        indel_sort_vcf_command += ' --sample_name ' + str(args.sample_name)
        indel_sort_vcf_command += ' --enable_indel_calling ' + str(args.enable_indel_calling)
        indel_sort_vcf_command += ' --indel_calling '
        indel_sort_vcf_command += ' --prefer_recall ' + str(args.prefer_recall)
        indel_sort_vcf_command += ' --cmdline ' + args.output_dir + '/tmp/CMD'
        indel_sort_vcf_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/5_MVI.log'
        commands_list += [indel_sort_vcf_command]

        if args.genotyping_mode_vcf_fn is not None or args.hybrid_mode_vcf_fn is not None:
            echo_list.append("[INFO] Add reference calls to the output VCF output")
            indel_genotyping_command = args.pypy + ' ' + main_entry + ' add_back_missing_variants_in_genotyping'
            indel_genotyping_command += ' --genotyping_mode_vcf_fn ' + str(args.genotyping_mode_vcf_fn)
            indel_genotyping_command += ' --hybrid_mode_vcf_fn ' + str(args.hybrid_mode_vcf_fn)
            indel_genotyping_command += ' --call_fn ' + args.output_dir + '/{}.vcf.gz'.format(args.indel_output_prefix)
            indel_genotyping_command += ' --output_fn ' + args.output_dir + '/{}.vcf'.format(args.indel_output_prefix)
            indel_genotyping_command += ' --candidates_folder ' + args.output_dir + '/tmp/candidates'
            indel_genotyping_command += ' 2>&1 | tee ' + args.output_dir + '/logs/6_GTI.log'
            commands_list += [indel_genotyping_command]

    def run_command_with_parallel_check(command, step_num, stdout=None):
        try:
            if "parallel" in command.lower():
                result = subprocess.run(command, shell=True, check=False, stdout=stdout)
                if result.returncode != 0:
                    sys.stderr.write(f"ERROR in STEP {step_num}, PARALLEL COMMAND FAILED WITH CODE {result.returncode}: {command}\n")
                    sys.exit(1)
                return result.returncode
            else:
                return subprocess.check_call(command, shell=True, stdout=stdout)
        except subprocess.CalledProcessError as e:
            sys.stderr.write(f"ERROR in STEP {step_num}, COMMAND FAILED: {command}\n")
            sys.exit(1)

    # EXECUTE COMMANDS STEP BY STEP
    skip_steps = args.skip_steps.rstrip().split(',') if args.skip_steps else None
    stdout = sys.stdout if args.tee is None else args.tee.stdin
    for i, (command, echo) in enumerate(zip(commands_list, echo_list)):
        logging(echo)
        logging("[INFO] RUN THE FOLLOWING COMMAND:")
        logging(command)
        logging("")
        if not args.dry_run:
            if skip_steps is not None and str(i + 1) in skip_steps:
                logging("[INFO] --skip_steps is enabled, skip running step {}.".format(i + 1))
                logging("")
                continue
            return_code = run_command_with_parallel_check(command, i + 1, stdout=stdout)
        logging("")

    if args.remove_intermediate_dir:
        logging("[INFO] Removing intermediate files in {}/tmp ...".format(args.output_dir))
        subprocess.run('rm -rf {}/tmp'.format(args.output_dir), shell=True)


def mosaic_calling_to(args):
    step = 1
    echo_list = []
    commands_list = []
    phasing_output_path = args.output_dir + '/tmp/phasing_output'
    input_bam_prefix = phasing_output_path + '/phased_bam_output/input_' if args.phase_input else args.bam_fn

    file_directory = os.path.dirname(os.path.realpath(__file__))
    main_entry = os.path.join(file_directory, "clair_mosaic_to.py")

    try:
        rc = subprocess.check_call('time', shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        time = 'time '
    except subprocess.CalledProcessError as e:
        time = ''

    # Mosaic Calling
    # STEP 1: EXTRACT CANDIDATES
    echo_list.append("[INFO] STEP 1: Extract Variant Candidates from Input BAM")
    step += 1
    ec_command = '( ' + time + args.parallel
    ec_command += ' --joblog ' + args.output_dir + '/logs/parallel_1_extract_tumor_candidates.log'
    ec_command += ' -C " " -j ' + str(args.threads)
    ec_command += ' ' + args.pypy + ' ' + main_entry + ' extract_candidates_calling'
    ec_command += ' --tumor_bam_fn ' + args.bam_fn
    ec_command += ' --ref_fn ' + args.ref_fn
    ec_command += ' --samtools ' + args.samtools
    ec_command += ' --snv_min_af ' + str(args.snv_min_af)
    ec_command += ' --indel_min_af ' + str(args.indel_min_af)
    ec_command += ' --chunk_id {2} '
    ec_command += ' --chunk_num {3} '
    ec_command += ' --ctg_name {1} '
    ec_command += ' --platform ' + args.platform
    ec_command += ' --min_coverage ' + str(args.min_coverage)
    ec_command += ' --min_bq ' + str(args.min_bq)
    ec_command += ' --bed_fn_source ' + str(args.bed_fn)
    ec_command += ' --bed_fn ' + os.path.join(args.output_dir, 'tmp', 'split_beds', '{1}')
    if args.enable_indel_calling:
        ec_command += ' --call_indels_only_in_these_regions ' + os.path.join(args.output_dir, 'tmp', 'split_indel_beds', '{1}')
        ec_command += ' --select_indel_candidates True'
    ec_command += ' --candidates_folder ' + args.output_dir + '/tmp/candidates'
    ec_command += ' --output_depth True '
    ec_command += ' --genotyping_mode_vcf_fn ' + str(args.genotyping_mode_vcf_fn)
    ec_command += ' --hybrid_mode_vcf_fn ' + str(args.hybrid_mode_vcf_fn)
    ec_command += ' :::: ' + os.path.join(args.output_dir, 'tmp', 'CHUNK_LIST')
    ec_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/1_EC.log'
    ec_command += ' && ' + args.pypy + ' ' + main_entry + ' concat_files'
    ec_command += ' --input_dir ' + "{}/tmp/candidates".format(args.output_dir)
    ec_command += ' --input_prefix ' + "SNV_CANDIDATES_FILE_"
    ec_command += ' --output_fn SNV_CANDIDATES_FILES'
    commands_list.append(ec_command)

    ## STEP 2: SNV PILEUP MODEL CALLING
    ## CREATE SNV PILEUP TENSOR
    echo_list.append("[INFO] STEP 2: SNV Pileup Model Calling\n")
    echo_list[-1] += ("[INFO] Create Tensors for SNV Pileup Model")
    cpt_aff_command = '( ' + time + args.parallel
    cpt_aff_command += ' --joblog ' + args.output_dir + '/logs/parallel_2-1_create_tensor_affirmative_snv.log'
    cpt_aff_command += ' -j ' + str(args.threads)
    cpt_aff_command += ' ' + args.pypy + ' ' + main_entry + ' create_tensor_pileup_calling'
    cpt_aff_command += ' --tumor_bam_fn ' + args.bam_fn
    cpt_aff_command += ' --ref_fn ' + args.ref_fn
    cpt_aff_command += ' --ctg_name {1/.}'
    cpt_aff_command += ' --min_bq ' + str(args.min_bq)
    cpt_aff_command += ' --max_depth {} '.format(str(args.bam_mplp_set_maxcnt)) if args.bam_mplp_set_maxcnt is not None else ""
    cpt_aff_command += ' --max_indel_length {} '.format(str(args.max_indel_length)) if args.max_indel_length is not None else ""
    cpt_aff_command += ' --samtools ' + args.samtools
    cpt_aff_command += ' --candidates_bed_regions {1}'
    cpt_aff_command += ' --tensor_can_fn ' + args.output_dir + '/tmp/pileup_tensor_can_affirmative/{1/} '
    cpt_aff_command += ' --platform ' + args.platform
    cpt_aff_command += ' :::: ' + args.output_dir + '/tmp/candidates/SNV_CANDIDATES_FILES'
    cpt_aff_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/2-1_CPT_Affirmative_SNV.log'
    commands_list += [cpt_aff_command]

    # PREDICT SNV
    echo_list.append("[INFO] SNV Pileup Model Prediction")
    p_predict_command = '( ' + time + args.parallel
    p_predict_command += ' --joblog ' + args.output_dir + '/logs/parallel_2-2_predict_snv.log'
    p_predict_command += ' -j ' + str(args.threads)
    p_predict_command += ' ' + args.python + ' ' + main_entry + ' predict'
    p_predict_command += ' --tensor_fn_acgt ' + args.output_dir + '/tmp/pileup_tensor_can_affirmative/{1/} '
    p_predict_command += ' --predict_fn ' + args.output_dir + '/tmp/predict/{1/} '
    p_predict_command += ' --chkpnt_fn_acgt ' + args.snv_pileup_affirmative_model_path
    p_predict_command += ' --use_gpu ' + str(args.use_gpu)
    p_predict_command += ' --platform ' + args.platform
    p_predict_command += ' --ctg_name {1/.}'
    p_predict_command += ' --pileup '
    p_predict_command += ' --show_ref ' if args.print_ref_calls else ""
    p_predict_command += ' --disable_indel_calling True'
    p_predict_command += ' :::: ' + args.output_dir + '/tmp/candidates/SNV_CANDIDATES_FILES'
    p_predict_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/2-2_PREDICT_SNV.log'
    commands_list += [p_predict_command]

    # CALL SNV VARIANTS
    echo_list.append("[INFO] SNV Pileup Model Calling Variants")
    cv_command = '( ' + time + args.parallel
    cv_command += ' --joblog ' + args.output_dir + '/logs/parallel_2-3_call_variants_snv.log'
    cv_command += ' -j ' + str(args.threads)
    cv_command += ' ' + args.python + ' ' + main_entry + ' call_variants'
    cv_command += ' --predict_fn ' + args.output_dir + '/tmp/predict/{1/} '
    cv_command += ' --call_fn ' + args.output_dir + '/tmp/vcf_output/p_{1/}.vcf'
    cv_command += ' --ref_fn ' + args.ref_fn
    cv_command += ' --platform ' + args.platform
    cv_command += ' --show_ref ' if args.print_ref_calls else ""
    cv_command += ' --disable_indel_calling True'
    cv_command += ' :::: ' + args.output_dir + '/tmp/candidates/SNV_CANDIDATES_FILES'
    cv_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/2-3_CALL_VARIANTS_SNV.log'
    commands_list += [cv_command]

    # MERGE CALLING SNV VCFs
    echo_list.append("[INFO] Merge SNV VCFs")
    p_mv_command = args.pypy + ' ' + main_entry + ' sort_vcf'
    p_mv_command += ' --ref_fn ' + args.ref_fn
    p_mv_command += ' --contigs_fn ' + os.path.join(args.output_dir, 'tmp', 'CONTIGS')
    p_mv_command += ' --input_dir ' + args.output_dir + '/tmp/vcf_output'
    p_mv_command += ' --vcf_fn_suffix ' + 'snv.vcf'
    p_mv_command += ' --output_fn ' + args.output_dir + '/tmp/vcf_output/snv_pileup.vcf'
    commands_list += [p_mv_command]

    if not args.disable_nonmosaic_tagging:
        # SNV NON-MOSAIC TAGGING
        echo_list.append("[INFO] Non-mosaic Tagging for SNV Variants")
        gf_command = '( ' + time + args.parallel
        gf_command += ' --joblog ' + args.output_dir + '/logs/parallel_nonmosaic_tagging_snv.log'
        gf_command += ' -j ' + str(args.threads)
        gf_command += ' ' + args.pypy + ' ' + main_entry + ' nonsomatic_tagging'
        gf_command += ' --pileup_vcf_fn ' + args.output_dir + '/tmp/vcf_output/snv_pileup.vcf'
        gf_command += ' --output_vcf_fn ' + args.output_dir + '/tmp/vcf_output/snv_nonmosaic_tagging_{1}.vcf'
        gf_command += ' --ctg_name {1} '
        gf_command += ' --pypy3 ' + args.pypy
        gf_command += ' --parallel ' + args.parallel
        gf_command += ' --show_ref ' if args.print_ref_calls else ''
        gf_command += ' --disable_print_nonmosaic_calls ' if args.disable_print_nonmosaic_calls else ''
        gf_command += ' --panel_of_normals {} '.format(
            args.panel_of_normals) if args.panel_of_normals is not None else ''
        gf_command += ' --panel_of_normals_require_allele_matching {} '.format(
            args.panel_of_normals_require_allele_matching) if args.panel_of_normals_require_allele_matching is not None else ''
        gf_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
        gf_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/NONMOSAIC_TAG_SNV.log'
        commands_list += [gf_command]

        # MERGE SNV NON-MOSAIC TAGGING VCFs
        echo_list.append("[INFO] Merge SNV Non-mosaic Tagging VCFs")
        p_mv_command = args.pypy + ' ' + main_entry + ' sort_vcf'
        p_mv_command += ' --ref_fn ' + args.ref_fn
        p_mv_command += ' --contigs_fn ' + os.path.join(args.output_dir, 'tmp', 'CONTIGS')
        p_mv_command += ' --input_dir ' + args.output_dir + '/tmp/vcf_output'
        p_mv_command += ' --vcf_fn_prefix ' + 'snv_nonmosaic_tagging_'
        p_mv_command += ' --output_fn ' + args.output_dir + '/tmp/vcf_output/snv_pileup_nonmosaic_tagging.vcf'
        commands_list += [p_mv_command]
    else:
        # SNV NON-MOSAIC TAGGING
        echo_list.append("[INFO] Non-mosaic Tagging for SNV Variants")
        nst_command = "ln -sf {} {}".format(args.output_dir + '/tmp/vcf_output/snv_pileup.vcf',
                                            args.output_dir + '/tmp/vcf_output/snv_pileup_nonmosaic_tagging.vcf')
        commands_list += [nst_command]

    if args.enable_baymgd_tagging:
        # SNV BAYMGD TAGGING
        echo_list.append("[INFO] BayMGD Tagging for SNV Variants")
        bt_command = '( ' + time + args.parallel
        bt_command += ' --joblog ' + args.output_dir + '/logs/parallel_baymgd_tagging_snv.log'
        bt_command += ' -j ' + str(args.threads)
        bt_command += ' ' + args.python + ' ' + main_entry + ' baymgd_tagging'
        bt_command += ' --pileup_vcf_fn ' + args.output_dir + '/tmp/vcf_output/snv_pileup_nonmosaic_tagging.vcf'
        bt_command += ' --output_vcf_fn ' + args.output_dir + '/tmp/vcf_output/snv_pileup_baymgd_tagging_{1}.vcf'
        bt_command += ' --ctg_name {1} '
        bt_command += ' --pypy3 ' + args.pypy
        bt_command += ' --parallel ' + args.parallel
        bt_command += ' --show_ref ' if args.print_ref_calls else ''
        bt_command += ' --disable_print_nonmosaic_calls ' if args.disable_print_nonmosaic_calls else ''
        bt_command += ' --gnomad_dir {} '.format(args.gnomad_dir) if args.gnomad_dir is not None else ''
        bt_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
        bt_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/BAYMGD_TAG_SNV.log'
        commands_list += [bt_command]

        # MERGE SNV BAYMGD TAGGING VCFs
        echo_list.append("[INFO] Merge SNV BayMGD Tagging VCFs")
        p_mv_command = args.pypy + ' ' + main_entry + ' sort_vcf'
        p_mv_command += ' --ref_fn ' + args.ref_fn
        p_mv_command += ' --contigs_fn ' + os.path.join(args.output_dir, 'tmp', 'CONTIGS')
        p_mv_command += ' --input_dir ' + args.output_dir + '/tmp/vcf_output'
        p_mv_command += ' --vcf_fn_prefix ' + 'snv_pileup_baymgd_tagging_'
        p_mv_command += ' --output_fn ' + args.output_dir + '/tmp/vcf_output/snv_pileup_baymgd_tagging.vcf'
        commands_list += [p_mv_command]
    else:
        # SNV BAYMGD TAGGING
        echo_list.append("[INFO] BayMGD Tagging for SNV Variants")
        bt_command = "ln -sf {} {}".format(args.output_dir + '/tmp/vcf_output/snv_pileup_nonmosaic_tagging.vcf',
                                            args.output_dir + '/tmp/vcf_output/snv_pileup_baymgd_tagging.vcf')
        commands_list += [bt_command]

    if args.enable_mosaicbase_tagging:
        # SNV MOSAICBASE TAGGING
        echo_list.append("[INFO] MosaicBase Tagging for SNV Variants")
        mt_command = '( ' + time + args.parallel
        mt_command += ' --joblog ' + args.output_dir + '/logs/parallel_mosaicbase_tagging_snv.log'
        mt_command += ' -j ' + str(args.threads)
        mt_command += ' ' + args.pypy + ' ' + main_entry + ' mosaicbase_tagging'
        mt_command += ' --pileup_vcf_fn ' + args.output_dir + '/tmp/vcf_output/snv_pileup_baymgd_tagging.vcf'
        mt_command += ' --output_vcf_fn ' + args.output_dir + '/tmp/vcf_output/snv_pileup_mosaicbase_tagging_{1}.vcf'
        mt_command += ' --ctg_name {1} '
        mt_command += ' --pypy3 ' + args.pypy
        mt_command += ' --parallel ' + args.parallel
        mt_command += ' --show_ref ' if args.print_ref_calls else ''
        mt_command += ' --disable_print_nonmosaic_calls ' if args.disable_print_nonmosaic_calls else ''
        mt_command += ' --mosaicbase_fn {} '.format(args.mosaicbase_fn) if args.mosaicbase_fn is not None else ''
        mt_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
        mt_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/MOSAICBASE_TAG_SNV.log'
        commands_list += [mt_command]

        # MERGE SNV MOSAICBASE TAGGING VCFs
        echo_list.append("[INFO] Merge SNV MosaicBase Tagging VCFs")
        p_mv_command = args.pypy + ' ' + main_entry + ' sort_vcf'
        p_mv_command += ' --ref_fn ' + args.ref_fn
        p_mv_command += ' --contigs_fn ' + os.path.join(args.output_dir, 'tmp', 'CONTIGS')
        p_mv_command += ' --input_dir ' + args.output_dir + '/tmp/vcf_output'
        p_mv_command += ' --vcf_fn_prefix ' + 'snv_pileup_mosaicbase_tagging_'
        p_mv_command += ' --output_fn ' + args.output_dir + '/tmp/vcf_output/snv_pileup_mosaicbase_tagging.vcf'
        commands_list += [p_mv_command]
    else:
        # SNV MOSAICBASE TAGGING
        echo_list.append("[INFO] MosaicBase Tagging for SNV Variants")
        mt_command = "ln -sf {} {}".format(args.output_dir + '/tmp/vcf_output/snv_pileup_baymgd_tagging.vcf',
                                            args.output_dir + '/tmp/vcf_output/snv_pileup_mosaicbase_tagging.vcf')
        commands_list += [mt_command]

    if args.platform != 'ilmn' and args.phase_input:
        echo_list.append("[INFO] Select Heterozygous SNP for Phasing")
        ssp_command = '( ' + time + args.parallel
        ssp_command += ' --joblog ' + args.output_dir + '/logs/phasing_log/parallel_1_select_hetero_snp_for_phasing.log'
        ssp_command += ' -j ' + str(args.threads)
        ssp_command += ' ' + args.pypy + ' ' + main_entry + ' select_hetero_snp_for_phasing'
        ssp_command += ' --tumor_vcf_fn ' + args.output_dir + '/tmp/vcf_output/snv_pileup.vcf'
        ssp_command += ' --output_folder ' + phasing_output_path + '/vcf'
        ssp_command += ' --ctg_name {1}'
        ssp_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
        ssp_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/phasing_log/1_select_hetero_snp_for_phasing.log'
        commands_list.append(ssp_command)

        echo_list.append("[INFO] Phase the Input BAM")
        if args.use_longphase_for_intermediate_phasing is not None:
            pt_command = '( ' + time + args.parallel
            pt_command += ' --joblog ' + args.output_dir + '/logs/phasing_log/parallel_2_phase_input.log'
            pt_command += ' -j ' + str(args.threads)
            pt_command += ' ' + args.longphase + ' phase '
            pt_command += ' -s ' + phasing_output_path + '/vcf/{1}.vcf'
            pt_command += ' -b ' + args.bam_fn
            pt_command += ' -r ' + args.ref_fn
            pt_command += ' -t ' + str(args.threads)
            pt_command += ' -o ' + phasing_output_path + '/phased_vcf_output/input_phased_{1}'
            pt_command += ' --ont' if args.platform == 'ont' else ' --pb'
            pt_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
            pt_command += ' && ' + args.parallel
            pt_command += ' -j ' + str(args.threads)
            pt_command += ' bgzip -f ' + phasing_output_path + '/phased_vcf_output/input_phased_{1}.vcf'
            pt_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
            pt_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/phasing_log/2_phase_input.log'
        else:
            pt_command = '( ' + time + args.parallel
            pt_command += ' --joblog ' + args.output_dir + '/logs/phasing_log/parallel_2_phase_input.log'
            pt_command += ' -j ' + str(args.threads)
            pt_command += ' ' + args.whatshap + ' phase '
            pt_command += ' --output ' + phasing_output_path + '/phased_vcf_output/input_phased_{1}.vcf.gz'
            pt_command += ' --reference ' + args.ref_fn
            pt_command += ' --chromosome {1}'
            pt_command += ' --distrust-genotypes'
            pt_command += ' --ignore-read-groups'
            pt_command += ' ' + phasing_output_path + '/vcf/{1}.vcf'
            pt_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
            pt_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/phasing_log/2_phase_input.log'

        tabix_command = args.parallel + ' -j ' + str(args.threads)
        tabix_command += ' tabix' + ' -f -p vcf'
        tabix_command += ' ' + phasing_output_path + '/phased_vcf_output/input_phased_{1}.vcf.gz'
        tabix_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
        commands_list.append(pt_command + ' && ' + tabix_command)

        echo_list.append("[INFO] Haplotag the Input BAM")
        if args.use_longphase_for_intermediate_haplotagging is not None:
            ht_command = '( ' + time + args.parallel
            ht_command += ' --joblog ' + args.output_dir + '/logs/phasing_log/parallel_3_haplotag_input.log'
            ht_command += ' -j ' + str(args.threads)
            ht_command += ' ' + args.longphase + ' haplotag'
            ht_command += ' -o ' + phasing_output_path + '/phased_bam_output/input_{1}'
            ht_command += ' --reference ' + args.ref_fn
            ht_command += ' --region {1} '
            ht_command += ' -s ' + phasing_output_path + '/phased_vcf_output/input_phased_{1}.vcf.gz'
            ht_command += ' -b ' + args.bam_fn
            ht_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
            ht_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/phasing_log/3_input_haplotag.log'
        else:
            ht_command = '( ' + time + args.parallel
            ht_command += ' --joblog ' + args.output_dir + '/logs/phasing_log/parallel_3_haplotag_input.log'
            ht_command += ' -j ' + str(args.threads)
            ht_command += ' ' + args.whatshap + ' haplotag'
            ht_command += ' --output ' + phasing_output_path + '/phased_bam_output/input_{1}.bam'
            ht_command += ' --reference ' + args.ref_fn
            ht_command += ' --regions {1} '
            ht_command += ' --ignore-read-groups'
            ht_command += ' ' + phasing_output_path + '/phased_vcf_output/input_phased_{1}.vcf.gz'
            ht_command += ' ' + args.bam_fn
            ht_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
            ht_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/phasing_log/3_input_haplotag.log'

        index_command = args.parallel + ' -j ' + str(args.threads)
        index_command += ' ' + args.samtools + ' index '
        index_command += ' -@' + str(args.threads)
        index_command += ' ' + phasing_output_path + '/phased_bam_output/input_{1}.bam'
        index_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
        commands_list.append(ht_command + ' && ' + index_command)

    if args.enable_post_filtering and args.platform != 'ilmn':
        # POST FILTERING for SNV Variants
        echo_list.append("[INFO] Post Filtering for SNV Variants")
        hap_g_command = '( ' + time + args.pypy + ' ' + main_entry + ' haplotype_filtering'
        hap_g_command += ' --tumor_bam_fn ' + input_bam_prefix
        hap_g_command += ' --ref_fn ' + args.ref_fn
        hap_g_command += ' --germline_vcf_fn ' + args.output_dir + '/tmp/vcf_output/snv_pileup.vcf'
        hap_g_command += ' --pileup_vcf_fn ' + args.output_dir + '/tmp/vcf_output/snv_pileup_mosaicbase_tagging.vcf'
        hap_g_command += ' --output_dir ' + args.output_dir + '/tmp/vcf_output'
        hap_g_command += ' --output_vcf_fn ' + args.output_dir + '/tmp/vcf_output/snv_pileup_filtering.vcf'
        hap_g_command += ' --cmrg_bed_fn {}'.format(args.cmrg_bed_fn) if args.cmrg_bed_fn is not None else ''
        hap_g_command += ' --samtools ' + args.samtools
        hap_g_command += ' --pypy3 ' + args.pypy
        hap_g_command += ' --parallel ' + args.parallel
        hap_g_command += ' --threads ' + str(args.threads)
        hap_g_command += ' --debug ' if args.debug else ''
        hap_g_command += ' --show_ref ' if args.print_ref_calls else ''
        hap_g_command += ' --enable_postfilter True '
        hap_g_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/POSTFILTER_SNV.log'
        commands_list += [hap_g_command]
    else:
        # POST FILTERING for SNV Variants
        echo_list.append("[INFO] Post Filtering for SNV Variants")
        pf_command = "ln -sf {} {}".format(args.output_dir + '/tmp/vcf_output/snv_pileup_mosaicbase_tagging.vcf',
                                            args.output_dir + '/tmp/vcf_output/snv_pileup_filtering.vcf')
        commands_list += [pf_command]

    # STEP 3: SNV VCF POST-PROCESSING
    echo_list.append("[INFO] STEP 3: SNV VCF Post-processing")
    postprocess_vcf_command = '( ' + time + args.pypy + ' ' + main_entry + ' postprocess_vcf'
    postprocess_vcf_command += ' --ref_fn ' + args.ref_fn
    postprocess_vcf_command += ' --pileup_vcf_fn ' + args.output_dir + '/tmp/vcf_output/snv_pileup_filtering.vcf'
    postprocess_vcf_command += ' --output_fn ' + args.output_dir + '/{}.vcf'.format(args.snv_output_prefix)
    postprocess_vcf_command += ' --platform ' + args.platform
    postprocess_vcf_command += ' --qual ' + str(args.qual)
    postprocess_vcf_command += ' --qual_cutoff_phaseable_region ' + str(args.qual_cutoff_phaseable_region)
    postprocess_vcf_command += ' --qual_cutoff_unphaseable_region ' + str(args.qual_cutoff_unphaseable_region)
    postprocess_vcf_command += ' --sample_name ' + str(args.sample_name)
    postprocess_vcf_command += ' --disable_indel_calling True'
    postprocess_vcf_command += ' --cmdline ' + args.output_dir + '/tmp/CMD'
    postprocess_vcf_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/3_PV_SNV.log'
    commands_list += [postprocess_vcf_command]

    # ADD REFERENCE CALLs for SNV Calling
    if args.genotyping_mode_vcf_fn is not None or args.hybrid_mode_vcf_fn is not None:
        echo_list.append("[INFO] Add Reference Calls to the VCF Output for SNV Calling")
        genotyping_command = args.pypy + ' ' + main_entry + ' add_back_missing_variants_in_genotyping'
        genotyping_command += ' --genotyping_mode_vcf_fn ' + str(args.genotyping_mode_vcf_fn)
        genotyping_command += ' --hybrid_mode_vcf_fn ' + str(args.hybrid_mode_vcf_fn)
        genotyping_command += ' --call_fn ' + args.output_dir + '/{}.vcf.gz'.format(args.snv_output_prefix)
        genotyping_command += ' --output_fn ' + args.output_dir + '/{}.vcf'.format(args.snv_output_prefix)
        genotyping_command += ' --candidates_folder ' + args.output_dir + '/tmp/candidates'
        genotyping_command += ' 2>&1 | tee ' + args.output_dir + '/logs/4_GT.log'
        commands_list += [genotyping_command]

    if args.enable_indel_calling:
        # STEP 4: CREATE INDEL PILEUP TENSOR
        echo_list.append("[INFO] STEP 4: Indel Pileup Model Calling\n")
        echo_list[-1] += ("[INFO] Create Tensors for Indel Pileup Model")
        indel_cpt_aff_command = args.pypy + ' ' + main_entry + ' concat_files'
        indel_cpt_aff_command += ' --input_dir ' + "{}/tmp/candidates".format(args.output_dir)
        indel_cpt_aff_command += ' --input_prefix ' + "INDEL_CANDIDATES_FILE_"
        indel_cpt_aff_command += ' --output_fn INDEL_CANDIDATES_FILES '
        indel_cpt_aff_command += ' && ( ' + time + args.parallel
        indel_cpt_aff_command += ' --joblog ' + args.output_dir + '/logs/parallel_4-1_create_tensor_affirmative_indel.log'
        indel_cpt_aff_command += ' -j ' + str(args.threads)
        indel_cpt_aff_command += ' ' + args.pypy + ' ' + main_entry + ' create_tensor_pileup_calling'
        indel_cpt_aff_command += ' --tumor_bam_fn ' + args.bam_fn
        indel_cpt_aff_command += ' --ref_fn ' + args.ref_fn
        indel_cpt_aff_command += ' --ctg_name {1/.}'
        indel_cpt_aff_command += ' --min_bq ' + str(args.min_bq)
        indel_cpt_aff_command += ' --max_depth {} '.format(str(args.bam_mplp_set_maxcnt)) if args.bam_mplp_set_maxcnt is not None else ""
        indel_cpt_aff_command += ' --max_indel_length {} '.format(str(args.max_indel_length)) if args.max_indel_length is not None else ""
        indel_cpt_aff_command += ' --samtools ' + args.samtools
        indel_cpt_aff_command += ' --candidates_bed_regions {1}'
        indel_cpt_aff_command += ' --tensor_can_fn ' + args.output_dir + '/tmp/pileup_tensor_can_affirmative/{1/} '
        indel_cpt_aff_command += ' --platform ' + args.platform
        indel_cpt_aff_command += ' :::: ' + args.output_dir + '/tmp/candidates/INDEL_CANDIDATES_FILES'
        indel_cpt_aff_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/4-1_CPT_Affirmative_INDEL.log'
        commands_list += [indel_cpt_aff_command]

        ## PREDICT INDEL
        echo_list.append("[INFO] Indel Pileup Model Prediction")
        indel_p_predict_command = '( ' + time + args.parallel
        indel_p_predict_command += ' --joblog ' + args.output_dir + '/logs/parallel_4-2_predict_indel.log'
        indel_p_predict_command += ' -j ' + str(args.threads)
        indel_p_predict_command += ' ' + args.python + ' ' + main_entry + ' predict'
        indel_p_predict_command += ' --tensor_fn_acgt ' + args.output_dir + '/tmp/pileup_tensor_can_affirmative/{1/} '
        indel_p_predict_command += ' --predict_fn ' + args.output_dir + '/tmp/predict/{1/} '
        indel_p_predict_command += ' --chkpnt_fn_acgt ' + args.indel_pileup_affirmative_model_path
        indel_p_predict_command += ' --use_gpu ' + str(args.use_gpu)
        indel_p_predict_command += ' --platform ' + args.platform
        indel_p_predict_command += ' --ctg_name {1/.}'
        indel_p_predict_command += ' --pileup '
        indel_p_predict_command += ' --disable_indel_calling False '
        indel_p_predict_command += ' --show_ref ' if args.print_ref_calls else ""
        indel_p_predict_command += ' :::: ' + args.output_dir + '/tmp/candidates/INDEL_CANDIDATES_FILES'
        indel_p_predict_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/4-2_PREDICT_INDEL.log'
        commands_list += [indel_p_predict_command]

        # INDEL CALL VARIANTS
        echo_list.append("[INFO] Indel Pileup Model Calling Variants")
        indel_cv_command = '( ' + time + args.parallel
        indel_cv_command += ' --joblog ' + args.output_dir + '/logs/parallel_4-3_call_variants_indel.log'
        indel_cv_command += ' -j ' + str(args.threads)
        indel_cv_command += ' ' + args.python + ' ' + main_entry + ' call_variants'
        indel_cv_command += ' --predict_fn ' + args.output_dir + '/tmp/predict/{1/} '
        indel_cv_command += ' --call_fn ' + args.output_dir + '/tmp/vcf_output/p_{1/}.vcf'
        indel_cv_command += ' --platform ' + args.platform
        indel_cv_command += ' --disable_indel_calling False '
        indel_cv_command += ' --show_ref ' if args.print_ref_calls else ""
        indel_cv_command += ' :::: ' + args.output_dir + '/tmp/candidates/INDEL_CANDIDATES_FILES'
        indel_cv_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/4-3_CALL_VARIANTS_INDEL.log'
        commands_list += [indel_cv_command]

        # MERGE INDEL CALLING VCFs
        echo_list.append("[INFO] Merge Indel VCFs")
        indel_p_mv_command = args.pypy + ' ' + main_entry + ' sort_vcf'
        indel_p_mv_command += ' --ref_fn ' + args.ref_fn
        indel_p_mv_command += ' --contigs_fn ' + os.path.join(args.output_dir, 'tmp', 'CONTIGS')
        indel_p_mv_command += ' --input_dir ' + args.output_dir + '/tmp/vcf_output'
        indel_p_mv_command += ' --vcf_fn_suffix ' + 'indel.vcf'
        indel_p_mv_command += ' --output_fn ' + args.output_dir + '/tmp/vcf_output/indel_pileup.vcf'
        commands_list += [indel_p_mv_command]

        if not args.disable_nonmosaic_tagging:
            # INDEL NON-MOSAIC TAGGING
            echo_list.append("[INFO] Non-mosaic Tagging for Indel Variants")
            indel_gf_command = '( ' + time + args.parallel
            indel_gf_command += ' --joblog ' + args.output_dir + '/logs/parallel_nonmosaic_tagging_indel.log'
            indel_gf_command += ' -j ' + str(args.threads)
            indel_gf_command += ' ' + args.pypy + ' ' + main_entry + ' nonsomatic_tagging'
            indel_gf_command += ' --pileup_vcf_fn ' + args.output_dir + '/tmp/vcf_output/indel_pileup.vcf'
            indel_gf_command += ' --output_vcf_fn ' + args.output_dir + '/tmp/vcf_output/indel_nonmosaic_tagging_{1}.vcf'
            indel_gf_command += ' --ctg_name {1} '
            indel_gf_command += ' --pypy3 ' + args.pypy
            indel_gf_command += ' --parallel ' + args.parallel
            indel_gf_command += ' --show_ref ' if args.print_ref_calls else ''
            indel_gf_command += ' --disable_print_nonmosaic_calls ' if args.disable_print_nonmosaic_calls else ''
            indel_gf_command += ' --panel_of_normals {} '.format(
                args.panel_of_normals) if args.panel_of_normals is not None else ''
            indel_gf_command += ' --panel_of_normals_require_allele_matching {} '.format(
                args.panel_of_normals_require_allele_matching) if args.panel_of_normals_require_allele_matching is not None else ''
            indel_gf_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
            indel_gf_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/NONMOSAIC_TAG_INDEL.log'
            commands_list += [indel_gf_command]

            # MERGE INDEL NON-MOSAIC TAGGING VCFs
            echo_list.append("[INFO] Merge Indel Non-mosaic Tagging VCFs")
            indel_p_mv_command = args.pypy + ' ' + main_entry + ' sort_vcf'
            indel_p_mv_command += ' --ref_fn ' + args.ref_fn
            indel_p_mv_command += ' --contigs_fn ' + os.path.join(args.output_dir, 'tmp', 'CONTIGS')
            indel_p_mv_command += ' --input_dir ' + args.output_dir + '/tmp/vcf_output'
            indel_p_mv_command += ' --vcf_fn_prefix ' + 'indel_nonmosaic_tagging_'
            indel_p_mv_command += ' --output_fn ' + args.output_dir + '/tmp/vcf_output/indel_pileup_nonmosaic_tagging.vcf'
            commands_list += [indel_p_mv_command]
        else:
            # INDEL NON-MOSAIC TAGGING
            echo_list.append("[INFO] Non-mosaic Tagging for SNV Variants")
            indel_mt_command = "ln -sf {} {}".format(args.output_dir + '/tmp/vcf_output/indel_pileup.vcf',
                                                      args.output_dir + '/tmp/vcf_output/indel_pileup_nonmosaic_tagging.vcf')
            commands_list += [indel_mt_command]

        if args.enable_baymgd_tagging:
            # INDEL BAYMGD TAGGING
            echo_list.append("[INFO] BayMGD Tagging for Indel Variants")
            indel_bt_command = '( ' + time + args.parallel
            indel_bt_command += ' --joblog ' + args.output_dir + '/logs/parallel_baymgd_tagging_indel.log'
            indel_bt_command += ' -j ' + str(args.threads)
            indel_bt_command += ' ' + args.python + ' ' + main_entry + ' baymgd_tagging'
            indel_bt_command += ' --pileup_vcf_fn ' + args.output_dir + '/tmp/vcf_output/indel_pileup_nonmosaic_tagging.vcf'
            indel_bt_command += ' --output_vcf_fn ' + args.output_dir + '/tmp/vcf_output/indel_pileup_baymgd_tagging_{1}.vcf'
            indel_bt_command += ' --ctg_name {1} '
            indel_bt_command += ' --pypy3 ' + args.pypy
            indel_bt_command += ' --parallel ' + args.parallel
            indel_bt_command += ' --show_ref ' if args.print_ref_calls else ''
            indel_bt_command += ' --disable_print_nonmosaic_calls ' if args.disable_print_nonmosaic_calls else ''
            indel_bt_command += ' --gnomad_dir {} '.format(args.gnomad_dir) if args.gnomad_dir is not None else ''
            indel_bt_command += ' --is_indel '
            indel_bt_command += ' :::: ' + args.output_dir + '/tmp/CONTIGS'
            indel_bt_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/BAYMGD_TAG_INDEL.log'
            commands_list += [indel_bt_command]

            # MERGE INDEL BAYMGD TAGGING VCFs
            echo_list.append("[INFO] Merge Indel BayMGD Tagging VCFs")
            indel_p_mv_command = args.pypy + ' ' + main_entry + ' sort_vcf'
            indel_p_mv_command += ' --ref_fn ' + args.ref_fn
            indel_p_mv_command += ' --contigs_fn ' + os.path.join(args.output_dir, 'tmp', 'CONTIGS')
            indel_p_mv_command += ' --input_dir ' + args.output_dir + '/tmp/vcf_output'
            indel_p_mv_command += ' --vcf_fn_prefix ' + 'indel_pileup_baymgd_tagging_'
            indel_p_mv_command += ' --output_fn ' + args.output_dir + '/tmp/vcf_output/indel_pileup_baymgd_tagging.vcf'
            commands_list += [indel_p_mv_command]
        else:
            # INDEL BAYMGD TAGGING
            echo_list.append("[INFO] BayMGD Tagging for Indel Variants")
            indel_bt_command = "ln -sf {} {}".format(args.output_dir + '/tmp/vcf_output/indel_pileup_nonmosaic_tagging.vcf',
                                               args.output_dir + '/tmp/vcf_output/indel_pileup_baymgd_tagging.vcf')
            commands_list += [indel_bt_command]

        if args.enable_post_filtering and args.platform != 'ilmn':
            # POST FILTERING for INDEL Variants
            echo_list.append("[INFO] Post Filtering for Indel Variants")
            indel_hap_g_command = '( ' + time + args.pypy + ' ' + main_entry + ' haplotype_filtering'
            indel_hap_g_command += ' --tumor_bam_fn ' + input_bam_prefix
            indel_hap_g_command += ' --ref_fn ' + args.ref_fn
            indel_hap_g_command += ' --germline_vcf_fn ' + args.output_dir + '/tmp/vcf_output/snv_pileup.vcf'
            indel_hap_g_command += ' --pileup_vcf_fn ' + args.output_dir + '/tmp/vcf_output/indel_pileup_baymgd_tagging.vcf'
            indel_hap_g_command += ' --output_dir ' + args.output_dir + '/tmp/vcf_output'
            indel_hap_g_command += ' --output_vcf_fn ' + args.output_dir + '/tmp/vcf_output/indel_pileup_filtering.vcf'
            indel_hap_g_command += ' --cmrg_bed_fn {}'.format(args.cmrg_bed_fn) if args.cmrg_bed_fn is not None else ''
            indel_hap_g_command += ' --samtools ' + args.samtools
            indel_hap_g_command += ' --pypy3 ' + args.pypy
            indel_hap_g_command += ' --parallel ' + args.parallel
            indel_hap_g_command += ' --threads ' + str(args.threads)
            indel_hap_g_command += ' --debug ' if args.debug else ''
            indel_hap_g_command += ' --show_ref ' if args.print_ref_calls else ''
            indel_hap_g_command += ' --is_indel '
            indel_hap_g_command += ' --enable_postfilter True '
            indel_hap_g_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/POSTFILTER_INDEL.log'
            commands_list += [indel_hap_g_command]
        else:
            # POST FILTERING for INDEL Variants
            echo_list.append("[INFO] Post Filtering for Indel Variants")
            indel_pf_command = "ln -sf {} {}".format(args.output_dir + '/tmp/vcf_output/indel_pileup_baymgd_tagging.vcf',
                                               args.output_dir + '/tmp/vcf_output/indel_pileup_filtering.vcf')
            commands_list += [indel_pf_command]

        # INDEL VCF POST-PROCESSING
        echo_list.append("[INFO] STEP 5: Indel VCF Post-processing")
        indel_postprocess_vcf_command = '( ' + time + args.pypy + ' ' + main_entry + ' postprocess_vcf'
        indel_postprocess_vcf_command += ' --ref_fn ' + args.ref_fn
        indel_postprocess_vcf_command += ' --pileup_vcf_fn ' + args.output_dir + '/tmp/vcf_output/indel_pileup_filtering.vcf'
        indel_postprocess_vcf_command += ' --output_fn ' + args.output_dir + '/{}.vcf'.format(args.indel_output_prefix)
        indel_postprocess_vcf_command += ' --platform ' + args.platform
        indel_postprocess_vcf_command += ' --qual ' + str(args.qual_indel)
        indel_postprocess_vcf_command += ' --qual_cutoff_phaseable_region ' + str(args.qual_indel_cutoff_phaseable_region)
        indel_postprocess_vcf_command += ' --qual_cutoff_unphaseable_region ' + str(args.qual_indel_cutoff_unphaseable_region)
        indel_postprocess_vcf_command += ' --sample_name ' + str(args.sample_name)
        indel_postprocess_vcf_command += ' --disable_indel_calling False'
        indel_postprocess_vcf_command += ' --indel_calling '
        indel_postprocess_vcf_command += ' --cmdline ' + args.output_dir + '/tmp/CMD'
        indel_postprocess_vcf_command += ' ) 2>&1 | tee ' + args.output_dir + '/logs/5_PV_INDEL.log'
        commands_list += [indel_postprocess_vcf_command]

        # ADD REFERENCE CALLs for Indel Calling
        if args.genotyping_mode_vcf_fn is not None or args.hybrid_mode_vcf_fn is not None:
            echo_list.append("[INFO] Add Reference Calls to the VCF Output for Indel Calling")
            indel_genotyping_command = args.pypy + ' ' + main_entry + ' add_back_missing_variants_in_genotyping'
            indel_genotyping_command += ' --genotyping_mode_vcf_fn ' + str(args.genotyping_mode_vcf_fn)
            indel_genotyping_command += ' --hybrid_mode_vcf_fn ' + str(args.hybrid_mode_vcf_fn)
            indel_genotyping_command += ' --call_fn ' + args.output_dir + '/{}.vcf.gz'.format(args.indel_output_prefix)
            indel_genotyping_command += ' --output_fn ' + args.output_dir + '/{}.vcf'.format(args.indel_output_prefix)
            indel_genotyping_command += ' --candidates_folder ' + args.output_dir + '/tmp/candidates'
            indel_genotyping_command += ' 2>&1 | tee ' + args.output_dir + '/logs/6_GT_INDEL.log'
            commands_list += [indel_genotyping_command]

    def run_command_with_parallel_check(command, step_num, stdout=None):
        try:
            if "parallel" in command.lower():
                result = subprocess.run(command, shell=True, check=False, stdout=stdout)
                if result.returncode != 0:
                    sys.stderr.write(f"ERROR in STEP {step_num}, PARALLEL COMMAND FAILED WITH CODE {result.returncode}: {command}\n")
                    sys.exit(1)
                return result.returncode
            else:
                return subprocess.check_call(command, shell=True, stdout=stdout)
        except subprocess.CalledProcessError as e:
            sys.stderr.write(f"ERROR in STEP {step_num}, COMMAND FAILED: {command}\n")
            sys.exit(1)

    # EXECUTE COMMANDS STEP BY STEP
    skip_steps = args.skip_steps.rstrip().split(',') if args.skip_steps else None
    stdout = sys.stdout if args.tee is None else args.tee.stdin
    for i, (command, echo) in enumerate(zip(commands_list, echo_list)):
        logging(echo)
        logging("[INFO] RUN THE FOLLOWING COMMAND:")
        logging(command)
        logging("")
        if not args.dry_run:
            if skip_steps is not None and str(i + 1) in skip_steps:
                logging("[INFO] --skip_steps is enabled, skip running step {}.".format(i + 1))
                logging("")
                continue
            return_code = run_command_with_parallel_check(command, i + 1, stdout=stdout)
        logging("")

    if args.remove_intermediate_dir:
        logging("[INFO] Removing intermediate files in {}/tmp ...".format(args.output_dir))
        subprocess.run('rm -rf {}/tmp'.format(args.output_dir), shell=True)


def mosaic_parser_basic():
    parser = argparse.ArgumentParser(add_help=False)

    optional_params = parser.add_argument_group('Parameters check')

    optional_params.add_argument(
        "--control_bam_fn",
        type=str,
        default=None,
        help="Control BAM file input. The input file must be samtools indexed."
    )

    return parser


def mosaic_parser_tn():
    parser = argparse.ArgumentParser(
        description="Run Clair-Mosaic for mosiac variant calling. Example run: run_clair_mosaic --bam_fn INPUT_BAM --control_bam_fn CONTROL_BAM -R REF -o OUTPUT_DIR -t THREADS -p PLATFORM")

    # print version
    parser.add_argument('-v', '--version', action='version',
                        version='%(prog)s {}'.format(param_tn.version))

    required_params = parser.add_argument_group('Required parameters')
    required_params.add_argument(
        "--bam_fn",
        type=str,
        required=True,
        default=None,
        help="Input BAM file input. The input file must be samtools indexed."
    )

    required_params.add_argument(
        "--control_bam_fn",
        type=str,
        required=True,
        default=None,
        help="Control BAM file input. The input file must be samtools indexed."
    )

    required_params.add_argument(
        "-R",
        "--ref_fn",
        type=str,
        required=True,
        default=None,
        help="FASTA reference file input. The input file must be samtools indexed."
    )

    required_params.add_argument(
        "-o",
        "--output_dir",
        type=str,
        required=True,
        default=None,
        help="VCF output directory."
    )

    required_params.add_argument(
        "-t",
        "--threads",
        required=True,
        type=int,
        default=None,
        help="Max #threads to be used."
    )

    required_params.add_argument(
        "-p",
        "--platform",
        required=True,
        type=str,
        default=None,
        help="Select the sequencing platform of the input. Possible options: {ont_r10_dorado_sup_4khz, ont_r10_dorado_hac_4khz, ont_r10_dorado_sup_5khz, ont_r10_guppy_sup_4khz, ont_r10_guppy_hac_5khz, ilmn, hifi_revio}."
    )

    optional_params = parser.add_argument_group('Commonly used parameters')
    optional_params.add_argument(
        "-P",
        "--pileup_model_path",
        type=str,
        default=None,
        help="Specify the path to your own mosaic calling pileup model."
    )

    optional_params.add_argument(
        "-c",
        "--ctg_name",
        type=str,
        default=None,
        help="The name of the contigs to be processed. Split by ',' for multiple contigs. Default: all contigs will be processed."
    )

    region_group = optional_params.add_mutually_exclusive_group(required=False)
    region_group.add_argument(
        "-r",
        "--region",
        type=str,
        default=None,
        help="A region to be processed. Format: `ctg_name:start-end` (start is 1-based)."
    )

    region_group.add_argument(
        "-b",
        "--bed_fn",
        type=str,
        default=None,
        help="Path to a BED file. Call variants only in the provided BED regions."
    )

    region_group.add_argument(
        "-G",
        "--genotyping_mode_vcf_fn",
        type=str,
        default=None,
        help="VCF file input containing candidate sites to be genotyped. Variants will only be called at the sites in the VCF file if provided."
    )

    optional_params.add_argument(
        "-H",
        "--hybrid_mode_vcf_fn",
        type=str,
        default=None,
        help="Enable hybrid calling mode that combines the de novo calling results and genotyping results at the positions in the VCF file given."
    )

    mode_group = optional_params.add_mutually_exclusive_group(required=False)
    mode_group.add_argument(
        '-q',
        "--qual",
        type=int,
        default=None,
        help="If set, variants with >QUAL will be marked as PASS, or LowQual otherwise."
    )

    optional_params.add_argument(
        "--snv_min_af",
        type=float,
        default=None,
        help="Minimal SNV AF required for a variant to be called. Decrease SNV_MIN_AF might increase a bit of sensitivity, but in trade of precision, speed and accuracy. Default: 0.05."
    )

    optional_params.add_argument(
        "--indel_min_af",
        type=float,
        default=None,
        help="Minimal Indel AF required for a variant to be called. Decrease INDEL_MIN_AF might increase a bit of sensitivity, but in trade of precision, speed and accuracy. Default: 0.1 for ONT, 0.05 for other platforms."
    )

    optional_params.add_argument(
        "--indel_max_af_in_normal",
        type=float,
        default=None,
        help="Maximal Indel AF allowed in normal BAM for a called variant If set, variants with NAF<INDEL_MAX_AF_IN_NORMAL will be marked LowQual. Default: None."
    )

    optional_params.add_argument(
        "--min_coverage",
        type=int,
        default=None,
        help="Minimal coverage required for a variant to be called. Default: 4."
    )

    optional_params.add_argument(
        "--chunk_size",
        type=int,
        default=None,
        help="The size of each chuck for parallel processing. Default: 5000000."
    )

    optional_params.add_argument(
        "-s",
        "--sample_name",
        type=str,
        default="SAMPLE",
        help="Define the sample name to be shown in the VCF file. Default: SAMPLE."
    )

    optional_params.add_argument(
        "--output_prefix",
        type=str,
        default="snv",
        help="Prefix for output VCF filename. Default: output."
    )

    optional_params.add_argument(
        "--remove_intermediate_dir",
        action='store_true',
        help="Remove intermediate directory before finishing to save disk space."
    )

    optional_params.add_argument(
        "--include_all_ctgs",
        action='store_true',
        help="Call variants on all contigs, otherwise call in chr{1..22} and {1..22}."
    )

    optional_params.add_argument(
        "--print_ref_calls",
        action='store_true',
        help="Show reference calls (0/0) in VCF file."
    )

    optional_params.add_argument(
        "--print_germline_calls",
        action='store_true',
        help="Show germline calls in VCF file."
    )

    optional_params.add_argument(
        '-d',
        "--dry_run",
        action='store_true',
        help="Print the commands that will be ran."
    )

    optional_params.add_argument(
        "--python",
        type=str,
        default="python3",
        help="Absolute path of python, python3 >= 3.9 is required."
    )

    optional_params.add_argument(
        "--pypy",
        type=str,
        default="pypy3",
        help="Absolute path of pypy3, pypy3 >= 3.6 is required."
    )

    optional_params.add_argument(
        "--samtools",
        type=str,
        default="samtools",
        help="Absolute path of samtools, samtools version >= 1.10 is required."
    )

    optional_params.add_argument(
        "--parallel",
        type=str,
        default="parallel",
        help="Absolute path of parallel, parallel >= 20191122 is required."
    )

    # options for advanced users
    optional_params.add_argument(
        "--normal_vcf_fn",
        type=str,
        default=None,
        help="EXPERIMENTAL: Path to normal VCF file with pattern *.vcf.gz. Setting this will skip varaint calling on normal BAM file input"
    )

    ##Apply postfiltering
    optional_params.add_argument(
        "--enable_post_filtering",
        action='store_true',
        help="Enable variants post-processing. Default: Disabled."
    )

    optional_params.add_argument(
        "--panel_of_normals",
        type=str,
        default=None,
        help="The path of the panel of normals (PoNs) used for tagging non-mosaic variants. Split by ',' if using multiple PoNs. Default: 'gnomad.r2.1.af-ge-0.001.sites.vcf.gz,dbsnp.b138.non-somatic.sites.vcf.gz,1000g-pon.sites.vcf.gz,CoLoRSdb.GRCh38.v1.1.0.deepvariant.glnexus.af-ge-0.001.vcf.gz'."
    )

    optional_params.add_argument(
        "--panel_of_normals_require_allele_matching",
        type=str,
        default=None,
        help="Use together with `--panel_of_normals`. Whether to require allele matching for each PoN. Split by ',' if using multiple PoNs. Default: 'True,True,False,False'."
    )

    optional_params.add_argument(
        "--disable_nonmosaic_tagging",
        action='store_true',
        help="Disable non-mosaic variants tagging using panel of normals (PoNs). Default: Enabled."
    )

    optional_params.add_argument(
        "--gnomad_dir",
        type=str,
        default=None,
        help="The path of the gnomAD population database used for BayMGD tagging."
    )

    optional_params.add_argument(
        "--enable_baymgd_tagging",
        action='store_true',
        help="Enable BayMGD tagging. Default: Disabled."
    )

    optional_params.add_argument(
        "--mosaicbase_fn",
        type=str,
        default=None,
        help="The path of the MosaicBase used for tagging mosaic variants. Default: 'MosaicBase.GRCh38.simplified.vcf.gz'."
    )

    optional_params.add_argument(
        "--enable_mosaicbase_tagging",
        action='store_true',
        help="Enable MosaicBase tagging. Default: Disabled."
    )

    optional_params.add_argument(
        "--disable_print_nonmosaic_calls",
        action='store_true',
        help="Do not print those non-mosaic variants tagged by `--panel_of_normals`."
    )

    optional_params.add_argument(
        "--call_variants_only_in_cmrg_bed_fn",
        type=str2bool,
        default=False,
        help="Call variants only in CMRG regions. Default: False."
    )

    optional_params.add_argument(
        "--cmrg_bed_fn",
        type=str,
        default=None,
        help="CMRG regions. Supersede by `--bed_fn`. Default: 'CMRGv1.0.GRCh38.bed'."
    )

    optional_params.add_argument(
        "--enable_clair3_germline_output",
        action='store_true',
        help="EXPERIMENTAL: Use Clair3 default calling settings than Clair3 fast calling setting for tumor and normal germline varaint calling. The calling time would increase ~40 percent, Default: disabled"
    )

    halotagging_group = optional_params.add_mutually_exclusive_group(required=False)
    halotagging_group.add_argument(
        "--disable_phasing",
        action='store_true',
        help="EXPERIMENTAL: Disable phasing with longphase or whatshap. Usually leads to significant performance loss."
    )

    halotagging_group.add_argument(
        "--haplotagged_tumor_bam_provided_so_skip_intermediate_phasing_and_haplotagging",
        action='store_true',
        help="EXPERIMENTAL: Use haplotagged tumor bam as input, If enabled, will skip intermediate phasing and haplotagging, and the haplotype information will be acquired from haplotagged tumor BAM. Default: disabled."
    )

    clair3_params = parser.add_argument_group('Clair3 parameters')

    clair3_params.add_argument(
        "--clair3_path",
        type=str_none,
        default=None,
        help='Clair3 main entry path.'
    )

    clair3_params.add_argument(
        "--clair3_model_path",
        type=str,
        default=None,
        help='Clair3 pileup and full-alignment model path.'
    )

    clair3_params.add_argument(
        "--longphase",
        type=str,
        default=None,
        help="Absolute path of longphase, longphase >= 1.7 is required."
    )

    clair3_params.add_argument(
        "--whatshap",
        type=str,
        default=None,
        help="Absolute path of whatshap, whatshap >= 1.0 is required."
    )

    clair3_params.add_argument(
        "--whatshap_for_phasing",
        type=str2bool,
        default=None,
        help="Use whatshap for phasing."
    )

    variant_phasing_group = optional_params.add_mutually_exclusive_group(required=False)

    variant_phasing_group.add_argument(
        "--use_heterozygous_snp_in_normal_sample_and_tumor_bam_for_intermediate_phasing",
        type=str2bool,
        default=None,
        help="EXPERIMENTAL: Use the heterozygous SNPs in normal VCF called by Clair3 and the tumor BAM for intermediate phasing. Option: {True, False}. Default: True."
    )

    variant_phasing_group.add_argument(
        "--use_heterozygous_snp_in_tumor_sample_and_tumor_bam_for_intermediate_phasing",
        type=str2bool,
        default=None,
        help="EXPERIMENTAL: Use the heterozygous SNPs in tumor VCF called by Clair3 and the tumor BAM for intermediate phasing. Option: {True, False}. Default: False."
    )

    variant_phasing_group.add_argument(
        "--use_heterozygous_snp_in_normal_sample_and_normal_bam_for_intermediate_phasing",
        type=str2bool,
        default=None,
        help="EXPERIMENTAL: Use the heterozygous SNPs in normal VCF called by Clair3 and the normal BAM for intermediate phasing. Option: {True, False}. Default: False."
    )

    variant_phasing_group.add_argument(
        "--use_heterozygous_snp_in_tumor_sample_and_normal_bam_for_intermediate_phasing",
        type=str2bool,
        default=None,
        help="EXPERIMENTAL: Use the heterozygous SNPs in tumor VCF called by Clair3 and the normal BAM for intermediate phasing. Option: {True, False}. Default: False."
    )

    optional_params.add_argument(
        "--use_heterozygous_indel_for_intermediate_phasing",
        type=str2bool,
        default=None,
        help="EXPERIMENTAL: Use the heterozygous Indels in normal and tumor VCFs called by Clair3 for intermediate phasing. Option: {True, False}. Default: True."
    )

    optional_params.add_argument(
        "--use_longphase_for_intermediate_haplotagging",
        type=str2bool,
        default=None,
        help="EXPERIMENTAL: Use the longphase instead of whatshap for intermediate haplotagging. Option: {True, False}. Default: True."
    )

    # options for internal process control
    ## Deprecated since v0.3.1. Use the heterozygous SNPs in normal VCF called by Clair3 for intermediate phasing. Option: {True, False}. Default: True.
    variant_phasing_group.add_argument(
        "--use_heterozygous_snp_in_normal_sample_for_intermediate_phasing",
        type=str2bool,
        default=None,
        help=SUPPRESS
    )

    ## Deprecated since v0.3.1. Use the heterozygous SNPs in tumor VCF called by Clair3 for intermediate phasing. Option: {True, False}. Default: False.
    variant_phasing_group.add_argument(
        "--use_heterozygous_snp_in_tumor_sample_for_intermediate_phasing",
        type=str2bool,
        default=None,
        help=SUPPRESS
    )

    ## Use normal BAM instead of tumor BAM for intermediate phasing. Option: {True, False}. Default: False.
    optional_params.add_argument(
        "--use_normal_bam_for_intermediate_phasing",
        type=str2bool,
        default=None,
        help=SUPPRESS
    )

    ont_params = parser.add_argument_group('ONT parameters')
    ont_params.add_argument(
        "--enable_indel_calling",
        action='store_true',
        help="Enable Indel calling. Default: Disabled."
    )

    ont_params.add_argument(
        "--indel_output_prefix",
        type=str,
        default="indel",
        help="Prefix for Indel output VCF filename. Default: indel."
    )

    ont_params.add_argument(
        "--indel_pileup_model_path",
        type=str,
        default=None,
        help="Specify the path to your own mosaic calling indel pileup model."
    )

    ## Prefer maximized recall
    mode_group.add_argument(
        "--prefer_recall",
        action='store_true',
        help=SUPPRESS
    )

    ## Prefer balance between precision and recall
    mode_group.add_argument(
        "--prefer_balance",
        action='store_true',
        help=SUPPRESS
    )

    ## Phase normal BAM in calling
    ont_params.add_argument(
        "--phase_control",
        type=str2bool,
        default=False,
        help=SUPPRESS
    )

    ## Phase input BAM in calling
    ont_params.add_argument(
        "--phase_input",
        type=str2bool,
        default=None,
        help=SUPPRESS
    )

    ## Minimum base quality
    optional_params.add_argument(
        "--min_bq",
        type=int,
        default=None,
        help=SUPPRESS
    )

    ##Clair3 options used in calling
    clair3_params.add_argument(
        "--clair3_option",
        type=clair3_option_type,
        default=None,
        help=SUPPRESS
    )

    ## Clair3 germline calling minimum coverage
    optional_params.add_argument(
        "--clair3_min_coverage",
        type=int,
        default=None,
        help=SUPPRESS
    )

    ## Clair3 germline snp minimum allele frequency
    optional_params.add_argument(
        "--clair3_snp_min_af",
        type=float,
        default=None,
        help=SUPPRESS
    )

    ## Clair3 germline snp minimum allele frequency
    optional_params.add_argument(
        "--clair3_indel_min_af",
        type=float,
        default=None,
        help=SUPPRESS
    )

    ##If set then will use GPUs for inference. CUDA required
    optional_params.add_argument(
        "-g",
        "--use_gpu",
        action='store_true',
        help=SUPPRESS
    )

    ##List of (ctg_name, chunk_id, chunk_num)
    optional_params.add_argument(
        "--chunk_list",
        type=str,
        default=None,
        help=SUPPRESS
    )

    optional_params.add_argument(
        "--debug",
        type=str2bool,
        default=False,
        help=SUPPRESS
    )

    optional_params.add_argument(
        "--chunk_num",
        type=int,
        default=None,
        help=SUPPRESS
    )

    optional_params.add_argument(
        "--output_path",
        type=str,
        default=None,
        help=SUPPRESS
    )

    optional_params.add_argument(
        "--skip_steps",
        type=str,
        default=None,
        help=SUPPRESS
    )

    optional_params.add_argument(
        "--tee",
        type=str,
        default=None,
        help=SUPPRESS
    )

    optional_params.add_argument(
        "--conda_prefix",
        type=str,
        default=None,
        help=SUPPRESS
    )

    optional_params.add_argument(
        "--cmdline",
        type=str,
        default=None,
        help=SUPPRESS
    )

    return parser


def mosaic_parser_to():
    parser = argparse.ArgumentParser(
        description="Run Clair-Mosaic for mosiac variant calling. Example run: run_clair_mosaic --bam_fn INPUT_BAM -R REF -o OUTPUT_DIR -t THREADS -p PLATFORM")

    # print version
    parser.add_argument('-v', '--version', action='version',
                        version='%(prog)s {}'.format(param_to.version))

    required_params = parser.add_argument_group('Required parameters')
    required_params.add_argument(
        "--bam_fn",
        type=str,
        required=True,
        default=None,
        help="Input BAM file input. The input file must be samtools indexed."
    )

    required_params.add_argument(
        "-R",
        "--ref_fn",
        type=str,
        required=True,
        default=None,
        help="FASTA reference file input. The input file must be samtools indexed."
    )

    required_params.add_argument(
        "-o",
        "--output_dir",
        type=str,
        required=True,
        default=None,
        help="VCF output directory."
    )

    required_params.add_argument(
        "-t",
        "--threads",
        required=True,
        type=int,
        default=None,
        help="Max #threads to be used."
    )

    required_params.add_argument(
        "-p",
        "--platform",
        required=True,
        type=str,
        default=None,
        help="Select the sequencing platform of the input. Possible options: {ont_r10_dorado_sup_4khz, ont_r10_dorado_hac_4khz, ont_r10_dorado_sup_5khz, ont_r10_guppy_sup_4khz, ont_r10_guppy_hac_5khz, ilmn, hifi_revio}."
    )

    optional_params = parser.add_argument_group('Commonly used parameters')
    optional_params.add_argument(
        "-s",
        "--sample_name",
        type=str,
        default="SAMPLE",
        help="Define the sample name to be shown in the VCF file. Default: SAMPLE."
    )

    optional_params.add_argument(
        "-c",
        "--ctg_name",
        type=str,
        default=None,
        help="The name of the contigs to be processed. Split by ',' for multiple contigs. Default: all contigs will be processed."
    )

    optional_params.add_argument(
        "--include_all_ctgs",
        action='store_true',
        help="Call variants on all contigs, otherwise call in chr{1..22,X,Y} and {1..22,X,Y}."
    )

    optional_params.add_argument(
        "-r",
        "--region",
        type=str,
        default=None,
        help="A region to be processed. Format: `ctg_name:start-end` (start is 1-based, including both end positions)."
    )

    optional_params.add_argument(
        "-b",
        "--bed_fn",
        type=str,
        default=None,
        help="Path to a BED file. Call variants only in the provided BED regions."
    )

    optional_params.add_argument(
        "-G",
        "--genotyping_mode_vcf_fn",
        type=str,
        default=None,
        help="VCF file input containing candidate sites to be genotyped. Variants will only be called at the sites in the VCF file if provided."
    )

    optional_params.add_argument(
        "-H",
        "--hybrid_mode_vcf_fn",
        type=str,
        default=None,
        help="Enable hybrid calling mode that combines the de novo calling results and genotyping results at the positions in the VCF file given."
    )

    optional_params.add_argument(
        "--print_ref_calls",
        action='store_true',
        help="Show reference calls (0/0) in VCF output."
    )

    optional_params.add_argument(
        "--enable_indel_calling",
        action='store_true',
        help="Enable Indel calling. Default: Disabled."
    )

    optional_params.add_argument(
        "--snv_min_af",
        type=float,
        default=None,
        help="Minimal SNV AF required for a variant to be called. Decrease SNV_MIN_AF might increase a bit of sensitivity, but in trade of precision, speed and accuracy. Default: 0.05."
    )

    optional_params.add_argument(
        "--indel_min_af",
        type=float,
        default=None,
        help="Minimal Indel AF required for a variant to be called. Default: 0.1."
    )

    ## Minimum base quality
    optional_params.add_argument(
        "--min_bq",
        type=int,
        default=None,
        help=SUPPRESS
    )

    optional_params.add_argument(
        "--bam_mplp_set_maxcnt",
        type=int,
        default=None,
        help=SUPPRESS
    )

    optional_params.add_argument(
        "--max_indel_length",
        type=int,
        default=None,
        help=SUPPRESS
    )

    optional_params.add_argument(
        "--min_coverage",
        type=int,
        default=None,
        help="Minimal coverage required for a variant to be called. Default: 4."
    )

    optional_params.add_argument(
        '-q',
        "--qual",
        type=int,
        default=None,
        help="If set, variants with >QUAL will be tagged as PASS, or LowQual otherwise. Default: ONT: 12, PacBio HiFi: 8, Illumina: 4."
    )

    optional_params.add_argument(
        "--qual_cutoff_phaseable_region",
        type=int,
        default=None,
        help="If set, variants called in phaseable regions with >QUAL will be tagged as PASS, or LowQual otherwise. Supersede by `--qual`."
    )

    optional_params.add_argument(
        "--qual_cutoff_unphaseable_region",
        type=int,
        default=None,
        help="If set, variants called in unphaseable regions with >QUAL will be tagged as PASS, or LowQual otherwise. Supersede by `--qual`."
    )

    optional_params.add_argument(
        "--qual_indel",
        type=int,
        default=None,
        help=SUPPRESS
    )

    optional_params.add_argument(
        "--qual_indel_cutoff_phaseable_region",
        type=int,
        default=None,
        help=SUPPRESS
    )

    optional_params.add_argument(
        "--qual_indel_cutoff_unphaseable_region",
        type=int,
        default=None,
        help=SUPPRESS
    )

    optional_params.add_argument(
        "--snv_output_prefix",
        type=str,
        default="snv",
        help="Prefix for SNV output VCF filename. Default: snv."
    )

    optional_params.add_argument(
        "--indel_output_prefix",
        type=str,
        default="indel",
        help="Prefix for Indel output VCF filename. Default: indel."
    )

    optional_params.add_argument(
        "--call_variants_only_in_cmrg_bed_fn",
        type=str2bool,
        default=False,
        help="Call variants only in CMRG regions. Default: False."
    )

    optional_params.add_argument(
        "--cmrg_bed_fn",
        type=str,
        default=None,
        help="CMRG regions. Supersede by `--bed_fn`. Default: 'CMRGv1.0.GRCh38.bed'."
    )

    optional_params.add_argument(
        "--call_indels_only_in_these_regions",
        type=str,
        default=None,
        help="Call Indel only in the provided regions. Supersede by `--bed_fn`. To call Indel in the whole genome, input a BED covering the whole genome."
    )

    optional_params.add_argument(
        "--panel_of_normals",
        type=str,
        default=None,
        help="The path of the panel of normals (PoNs) used for tagging non-mosaic variants. Split by ',' if using multiple PoNs. Default: 'gnomad.r2.1.af-ge-0.001.sites.vcf.gz,dbsnp.b138.non-somatic.sites.vcf.gz,1000g-pon.sites.vcf.gz,CoLoRSdb.GRCh38.v1.1.0.deepvariant.glnexus.af-ge-0.001.vcf.gz'."
    )

    optional_params.add_argument(
        "--panel_of_normals_require_allele_matching",
        type=str,
        default=None,
        help="Use together with `--panel_of_normals`. Whether to require allele matching for each PoN. Split by ',' if using multiple PoNs. Default: 'True,True,False,False'."
    )

    optional_params.add_argument(
        "--disable_nonmosaic_tagging",
        action='store_true',
        help="Disable non-mosaic variants tagging using panel of normals (PoNs). Default: Enabled."
    )

    optional_params.add_argument(
        "--gnomad_dir",
        type=str,
        default=None,
        help="The path of the gnomAD population database used for BayMGD tagging."
    )

    optional_params.add_argument(
        "--enable_baymgd_tagging",
        action='store_true',
        help="Enable BayMGD tagging. Default: Disabled."
    )

    optional_params.add_argument(
        "--mosaicbase_fn",
        type=str,
        default=None,
        help="The path of the MosaicBase used for tagging mosaic variants. Default: 'MosaicBase.GRCh38.simplified.vcf.gz'."
    )

    optional_params.add_argument(
        "--enable_mosaicbase_tagging",
        action='store_true',
        help="Enable MosaicBase tagging. Default: Disabled."
    )

    optional_params.add_argument(
        "--disable_print_nonmosaic_calls",
        action='store_true',
        help="Do not print those non-mosaic variants tagged by `--panel_of_normals`."
    )

    ##Apply postfiltering
    optional_params.add_argument(
        "--enable_post_filtering",
        action='store_true',
        help="Enable variants post-processing. Default: Disabled."
    )

    other_params = parser.add_argument_group('Other parameters')

    other_params.add_argument(
        "--snv_pileup_affirmative_model_path",
        type=str,
        default=None,
        help="Specify the path to your own SNV pileup affirmative model."
    )

    other_params.add_argument(
        "--indel_pileup_affirmative_model_path",
        type=str,
        default=None,
        help="Specify the path to your own Indel pileup affirmative model."
    )

    other_params.add_argument(
        '-d',
        "--dry_run",
        action='store_true',
        help="Print the commands that will be ran, but do not run them."
    )

    other_params.add_argument(
        "--chunk_size",
        type=int,
        default=None,
        help="The size of each chuck for parallel processing. Default: 5000000."
    )

    other_params.add_argument(
        "--remove_intermediate_dir",
        action='store_true',
        help="Remove the intermediate directory before finishing to save disk space."
    )

    other_params.add_argument(
        "--python",
        type=str,
        default="python3",
        help="Absolute path of python, python3 >= 3.9 is required."
    )

    other_params.add_argument(
        "--pypy",
        type=str,
        default="pypy3",
        help="Absolute path of pypy3, pypy3 >= 3.6 is required."
    )

    other_params.add_argument(
        "--samtools",
        type=str,
        default="samtools",
        help="Absolute path of samtools, samtools version >= 1.10 is required."
    )

    other_params.add_argument(
        "--parallel",
        type=str,
        default="parallel",
        help="Absolute path of parallel, parallel >= 20191122 is required."
    )

    other_params.add_argument(
        "--longphase",
        type=str,
        default=None,
        help="Absolute path of longphase, longphase >= 1.7 is required."
    )

    other_params.add_argument(
        "--whatshap",
        type=str,
        default=None,
        help="Absolute path of whatshap, whatshap >= 1.0 is required."
    )

    other_params.add_argument(
        "--use_longphase_for_intermediate_phasing",
        type=str2bool,
        default=None,
        help="Use longphase for intermediate phasing."
    )

    other_params.add_argument(
        "--use_whatshap_for_intermediate_phasing",
        type=str2bool,
        default=None,
        help="Use whatshap for intermediate phasing."
    )

    other_params.add_argument(
        "--disable_intermediate_phasing",
        action='store_true',
        help="Disable intermediate phasing, runs faster but reduces precision."
    )

    other_params.add_argument(
        "--use_longphase_for_intermediate_haplotagging",
        type=str2bool,
        default=None,
        help="Use longphase instead of whatshap for intermediate haplotagging."
    )

    ## Phase input BAM in calling
    other_params.add_argument(
        "--phase_input",
        type=str2bool,
        default=None,
        help=SUPPRESS
    )

    # options for internal process control
    ## Prefer maximized recall
    other_params.add_argument(
        "--prefer_recall",
        action='store_true',
        help=SUPPRESS
    )

    ## Prefer balance between precision and recall
    other_params.add_argument(
        "--prefer_balance",
        action='store_true',
        help=SUPPRESS
    )

    ##If set then will use GPUs for inference. CUDA required
    other_params.add_argument(
        "-g",
        "--use_gpu",
        action='store_true',
        help=SUPPRESS
    )

    ##List of (ctg_name, chunk_id, chunk_num)
    other_params.add_argument(
        "--chunk_list",
        type=str,
        default=None,
        help=SUPPRESS
    )

    other_params.add_argument(
        "--debug",
        type=str2bool,
        default=False,
        help=SUPPRESS
    )

    other_params.add_argument(
        "--chunk_num",
        type=int,
        default=None,
        help=SUPPRESS
    )

    other_params.add_argument(
        "--output_path",
        type=str,
        default=None,
        help=SUPPRESS
    )

    other_params.add_argument(
        "--skip_steps",
        type=str,
        default=None,
        help=SUPPRESS
    )

    other_params.add_argument(
        "--tee",
        type=str,
        default=None,
        help=SUPPRESS
    )

    other_params.add_argument(
        "--conda_prefix",
        type=str,
        default=None,
        help=SUPPRESS
    )

    other_params.add_argument(
        "--cmdline",
        type=str,
        default=None,
        help=SUPPRESS
    )

    return parser


def main():
    """
    Main interface for Clair-Mosaic.
    """

    global args

    call_start_time = time()

    parser = mosaic_parser_basic()
    args, _ = parser.parse_known_args()

    if args.control_bam_fn is not None:
        parser_tn = mosaic_parser_tn()
        args = parser_tn.parse_args()

        args.output_dir = folder_path_from(args.output_dir, create_not_found=True)
        tee_logger = os.path.join(args.output_dir,
                                  'run_clair_mosaic.log' if not args.dry_run else "run_clair_mosaic_dry_run.log")
        if os.path.exists(tee_logger):
            subprocess.run("mv {} {}".format(tee_logger, tee_logger + '.bak'), shell=True)
        try:
            args.tee = subprocess.Popen(['tee', tee_logger], stdin=subprocess.PIPE, bufsize=0)
        except:
            logging(log_warning("[WARNING] `tee` not found, disable `tee` logging!"))
            args.tee = None

        logging("")

        args = print_command_line_tn(args)
        args = check_args_tn(args)
        args = print_args_tn(args)
        mosaic_calling_tn(args)

        runtime = time() - call_start_time
        logging("[INFO] Total time elapsed: %im%.2fs\n" % (int(runtime / 60), int(runtime % 60)))
        if args.enable_indel_calling:
            logging("[INFO] Finish calling, SNV output VCF file: {}/{}.vcf.gz\n".format(args.output_dir,
                                                                                        args.output_prefix))
            logging("[INFO] Finish calling, Indel output VCF file: {}/{}.vcf.gz\n".format(args.output_dir,
                                                                                          args.indel_output_prefix))
        else:
            logging("[INFO] Finish calling, SNV output VCF file: {}/{}.vcf.gz\n".format(args.output_dir,
                                                                                        args.output_prefix))

    else:
        parser_to = mosaic_parser_to()
        args = parser_to.parse_args()

        args.output_dir = folder_path_from(args.output_dir, create_not_found=True)
        tee_logger = os.path.join(args.output_dir,
                                  'run_clair_mosaic.log' if not args.dry_run else "run_clair_mosaic_dry_run.log")
        if os.path.exists(tee_logger):
            subprocess.run("mv {} {}".format(tee_logger, tee_logger + '.bak'), shell=True)
        try:
            args.tee = subprocess.Popen(['tee', tee_logger], stdin=subprocess.PIPE, bufsize=0)
        except:
            logging(log_warning("[WARNING] `tee` not found, disable `tee` logging!"))
            args.tee = None

        logging("")

        args = print_command_line_to(args)
        args = check_args_to(args)
        args = print_args_to(args)
        mosaic_calling_to(args)

        runtime = time() - call_start_time
        logging("[INFO] Total time elapsed: %im%.2fs\n" % (int(runtime / 60), int(runtime % 60)))
        if args.enable_indel_calling:
            logging("[INFO] Finish calling, SNV output VCF file: {}/{}.vcf.gz\n".format(args.output_dir,
                                                                                        args.snv_output_prefix))
            logging("[INFO] Finish calling, Indel output VCF file: {}/{}.vcf.gz\n".format(args.output_dir,
                                                                                          args.indel_output_prefix))
        else:
            logging("[INFO] Finish calling, SNV output VCF file: {}/{}.vcf.gz\n".format(args.output_dir,
                                                                                        args.snv_output_prefix))

    if args.tee is not None:
        args.tee.stdin.close()


if __name__ == '__main__':
    main()
